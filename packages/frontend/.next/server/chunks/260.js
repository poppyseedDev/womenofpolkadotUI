exports.id=260,exports.ids=[260],exports.modules={673:(t,r,a)=>{/*! node-domexception. MIT License. Jimmy WÃ¤rting <https://jimmy.warting.se/opensource> */if(!globalThis.DOMException)try{let{MessageChannel:t}=a(1267),r=new t().port1,o=new ArrayBuffer;r.postMessage(o,[o,o])}catch(t){"DOMException"===t.constructor.name&&(globalThis.DOMException=t.constructor)}t.exports=globalThis.DOMException},5368:function(t,r){(function(t){"use strict";let r="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?Symbol:t=>`Symbol(${t})`;function noop(){}let a="undefined"!=typeof self?self:"undefined"!=typeof window?window:"undefined"!=typeof global?global:void 0;function typeIsObject(t){return"object"==typeof t&&null!==t||"function"==typeof t}let o=Promise,l=Promise.prototype.then,n=Promise.resolve.bind(o),i=Promise.reject.bind(o);function newPromise(t){return new o(t)}function PerformPromiseThen(t,r,a){return l.call(t,r,a)}function uponPromise(t,r,a){PerformPromiseThen(PerformPromiseThen(t,r,a),void 0,noop)}function uponRejection(t,r){uponPromise(t,void 0,r)}function setPromiseIsHandledToTrue(t){PerformPromiseThen(t,void 0,noop)}let s=(()=>{let t=a&&a.queueMicrotask;if("function"==typeof t)return t;let r=n(void 0);return t=>PerformPromiseThen(r,t)})();function reflectCall(t,r,a){if("function"!=typeof t)throw TypeError("Argument is not a function");return Function.prototype.apply.call(t,r,a)}function promiseCall(t,r,a){try{var o;return o=reflectCall(t,r,a),n(o)}catch(t){return i(t)}}let SimpleQueue=class SimpleQueue{constructor(){this._cursor=0,this._size=0,this._front={_elements:[],_next:void 0},this._back=this._front,this._cursor=0,this._size=0}get length(){return this._size}push(t){let r=this._back,a=r;16383===r._elements.length&&(a={_elements:[],_next:void 0}),r._elements.push(t),a!==r&&(this._back=a,r._next=a),++this._size}shift(){let t=this._front,r=t,a=this._cursor,o=a+1,l=t._elements,n=l[a];return 16384===o&&(r=t._next,o=0),--this._size,this._cursor=o,t!==r&&(this._front=r),l[a]=void 0,n}forEach(t){let r=this._cursor,a=this._front,o=a._elements;for(;(r!==o.length||void 0!==a._next)&&(r!==o.length||(o=(a=a._next)._elements,r=0,0!==o.length));)t(o[r]),++r}peek(){let t=this._front,r=this._cursor;return t._elements[r]}};function ReadableStreamReaderGenericInitialize(t,r){var a;t._ownerReadableStream=r,r._reader=t,"readable"===r._state?defaultReaderClosedPromiseInitialize(t):"closed"===r._state?(defaultReaderClosedPromiseInitialize(t),defaultReaderClosedPromiseResolve(t)):(a=r._storedError,defaultReaderClosedPromiseInitialize(t),defaultReaderClosedPromiseReject(t,a))}function ReadableStreamReaderGenericCancel(t,r){let a=t._ownerReadableStream;return ReadableStreamCancel(a,r)}function ReadableStreamReaderGenericRelease(t){var r,a;"readable"===t._ownerReadableStream._state?defaultReaderClosedPromiseReject(t,TypeError("Reader was released and can no longer be used to monitor the stream's closedness")):(r=t,a=TypeError("Reader was released and can no longer be used to monitor the stream's closedness"),defaultReaderClosedPromiseInitialize(r),defaultReaderClosedPromiseReject(r,a)),t._ownerReadableStream._reader=void 0,t._ownerReadableStream=void 0}function readerLockException(t){return TypeError("Cannot "+t+" a stream using a released reader")}function defaultReaderClosedPromiseInitialize(t){t._closedPromise=newPromise((r,a)=>{t._closedPromise_resolve=r,t._closedPromise_reject=a})}function defaultReaderClosedPromiseReject(t,r){void 0!==t._closedPromise_reject&&(setPromiseIsHandledToTrue(t._closedPromise),t._closedPromise_reject(r),t._closedPromise_resolve=void 0,t._closedPromise_reject=void 0)}function defaultReaderClosedPromiseResolve(t){void 0!==t._closedPromise_resolve&&(t._closedPromise_resolve(void 0),t._closedPromise_resolve=void 0,t._closedPromise_reject=void 0)}let u=r("[[AbortSteps]]"),d=r("[[ErrorSteps]]"),c=r("[[CancelSteps]]"),m=r("[[PullSteps]]"),b=Number.isFinite||function(t){return"number"==typeof t&&isFinite(t)},h=Math.trunc||function(t){return t<0?Math.ceil(t):Math.floor(t)};function assertDictionary(t,r){if(void 0!==t&&!("object"==typeof t||"function"==typeof t))throw TypeError(`${r} is not an object.`)}function assertFunction(t,r){if("function"!=typeof t)throw TypeError(`${r} is not a function.`)}function assertObject(t,r){if(!("object"==typeof t&&null!==t||"function"==typeof t))throw TypeError(`${r} is not an object.`)}function assertRequiredArgument(t,r,a){if(void 0===t)throw TypeError(`Parameter ${r} is required in '${a}'.`)}function assertRequiredField(t,r,a){if(void 0===t)throw TypeError(`${r} is required in '${a}'.`)}function convertUnrestrictedDouble(t){return Number(t)}function convertUnsignedLongLongWithEnforceRange(t,r){var a,o;let l=Number.MAX_SAFE_INTEGER,n=Number(t);if(!b(n=0===(a=n)?0:a))throw TypeError(`${r} is not a finite number`);if((n=0===(o=h(n))?0:o)<0||n>l)throw TypeError(`${r} is outside the accepted range of 0 to ${l}, inclusive`);return b(n)&&0!==n?n:0}function assertReadableStream(t,r){if(!IsReadableStream(t))throw TypeError(`${r} is not a ReadableStream.`)}function AcquireReadableStreamDefaultReader(t){return new ReadableStreamDefaultReader(t)}function ReadableStreamAddReadRequest(t,r){t._reader._readRequests.push(r)}function ReadableStreamFulfillReadRequest(t,r,a){let o=t._reader,l=o._readRequests.shift();a?l._closeSteps():l._chunkSteps(r)}function ReadableStreamGetNumReadRequests(t){return t._reader._readRequests.length}function ReadableStreamHasDefaultReader(t){let r=t._reader;return!!(void 0!==r&&IsReadableStreamDefaultReader(r))}let ReadableStreamDefaultReader=class ReadableStreamDefaultReader{constructor(t){if(assertRequiredArgument(t,1,"ReadableStreamDefaultReader"),assertReadableStream(t,"First parameter"),IsReadableStreamLocked(t))throw TypeError("This stream has already been locked for exclusive reading by another reader");ReadableStreamReaderGenericInitialize(this,t),this._readRequests=new SimpleQueue}get closed(){return IsReadableStreamDefaultReader(this)?this._closedPromise:i(defaultReaderBrandCheckException("closed"))}cancel(t){return IsReadableStreamDefaultReader(this)?void 0===this._ownerReadableStream?i(readerLockException("cancel")):ReadableStreamReaderGenericCancel(this,t):i(defaultReaderBrandCheckException("cancel"))}read(){let t,r;if(!IsReadableStreamDefaultReader(this))return i(defaultReaderBrandCheckException("read"));if(void 0===this._ownerReadableStream)return i(readerLockException("read from"));let a=newPromise((a,o)=>{t=a,r=o});return ReadableStreamDefaultReaderRead(this,{_chunkSteps:r=>t({value:r,done:!1}),_closeSteps:()=>t({value:void 0,done:!0}),_errorSteps:t=>r(t)}),a}releaseLock(){if(!IsReadableStreamDefaultReader(this))throw defaultReaderBrandCheckException("releaseLock");if(void 0!==this._ownerReadableStream){if(this._readRequests.length>0)throw TypeError("Tried to release a reader lock when that reader has pending read() calls un-settled");ReadableStreamReaderGenericRelease(this)}}};function IsReadableStreamDefaultReader(t){return!!(typeIsObject(t)&&Object.prototype.hasOwnProperty.call(t,"_readRequests"))&&t instanceof ReadableStreamDefaultReader}function ReadableStreamDefaultReaderRead(t,r){let a=t._ownerReadableStream;a._disturbed=!0,"closed"===a._state?r._closeSteps():"errored"===a._state?r._errorSteps(a._storedError):a._readableStreamController[m](r)}function defaultReaderBrandCheckException(t){return TypeError(`ReadableStreamDefaultReader.prototype.${t} can only be used on a ReadableStreamDefaultReader`)}Object.defineProperties(ReadableStreamDefaultReader.prototype,{cancel:{enumerable:!0},read:{enumerable:!0},releaseLock:{enumerable:!0},closed:{enumerable:!0}}),"symbol"==typeof r.toStringTag&&Object.defineProperty(ReadableStreamDefaultReader.prototype,r.toStringTag,{value:"ReadableStreamDefaultReader",configurable:!0});let p=Object.getPrototypeOf(Object.getPrototypeOf(async function*(){}).prototype);let ReadableStreamAsyncIteratorImpl=class ReadableStreamAsyncIteratorImpl{constructor(t,r){this._ongoingPromise=void 0,this._isFinished=!1,this._reader=t,this._preventCancel=r}next(){let nextSteps=()=>this._nextSteps();return this._ongoingPromise=this._ongoingPromise?PerformPromiseThen(this._ongoingPromise,nextSteps,nextSteps):nextSteps(),this._ongoingPromise}return(t){let returnSteps=()=>this._returnSteps(t);return this._ongoingPromise?PerformPromiseThen(this._ongoingPromise,returnSteps,returnSteps):returnSteps()}_nextSteps(){let t,r;if(this._isFinished)return Promise.resolve({value:void 0,done:!0});let a=this._reader;if(void 0===a._ownerReadableStream)return i(readerLockException("iterate"));let o=newPromise((a,o)=>{t=a,r=o});return ReadableStreamDefaultReaderRead(a,{_chunkSteps:r=>{this._ongoingPromise=void 0,s(()=>t({value:r,done:!1}))},_closeSteps:()=>{this._ongoingPromise=void 0,this._isFinished=!0,ReadableStreamReaderGenericRelease(a),t({value:void 0,done:!0})},_errorSteps:t=>{this._ongoingPromise=void 0,this._isFinished=!0,ReadableStreamReaderGenericRelease(a),r(t)}}),o}_returnSteps(t){if(this._isFinished)return Promise.resolve({value:t,done:!0});this._isFinished=!0;let r=this._reader;if(void 0===r._ownerReadableStream)return i(readerLockException("finish iterating"));if(!this._preventCancel){let a=ReadableStreamReaderGenericCancel(r,t);return ReadableStreamReaderGenericRelease(r),PerformPromiseThen(a,()=>({value:t,done:!0}),void 0)}return ReadableStreamReaderGenericRelease(r),n({value:t,done:!0})}};let y={next(){return IsReadableStreamAsyncIterator(this)?this._asyncIteratorImpl.next():i(streamAsyncIteratorBrandCheckException("next"))},return(t){return IsReadableStreamAsyncIterator(this)?this._asyncIteratorImpl.return(t):i(streamAsyncIteratorBrandCheckException("return"))}};function IsReadableStreamAsyncIterator(t){if(!typeIsObject(t)||!Object.prototype.hasOwnProperty.call(t,"_asyncIteratorImpl"))return!1;try{return t._asyncIteratorImpl instanceof ReadableStreamAsyncIteratorImpl}catch(t){return!1}}function streamAsyncIteratorBrandCheckException(t){return TypeError(`ReadableStreamAsyncIterator.${t} can only be used on a ReadableSteamAsyncIterator`)}void 0!==p&&Object.setPrototypeOf(y,p);let S=Number.isNaN||function(t){return t!=t};function CreateArrayFromList(t){return t.slice()}function CopyDataBlockBytes(t,r,a,o,l){new Uint8Array(t).set(new Uint8Array(a,o,l),r)}function ArrayBufferSlice(t,r,a){if(t.slice)return t.slice(r,a);let o=a-r,l=new ArrayBuffer(o);return CopyDataBlockBytes(l,0,t,r,o),l}function CloneAsUint8Array(t){let r=ArrayBufferSlice(t.buffer,t.byteOffset,t.byteOffset+t.byteLength);return new Uint8Array(r)}function DequeueValue(t){let r=t._queue.shift();return t._queueTotalSize-=r.size,t._queueTotalSize<0&&(t._queueTotalSize=0),r.value}function EnqueueValueWithSize(t,r,a){if(!(!("number"!=typeof a||S(a))&&!(a<0))||a===1/0)throw RangeError("Size must be a finite, non-NaN, non-negative number.");t._queue.push({value:r,size:a}),t._queueTotalSize+=a}function ResetQueue(t){t._queue=new SimpleQueue,t._queueTotalSize=0}let ReadableStreamBYOBRequest=class ReadableStreamBYOBRequest{constructor(){throw TypeError("Illegal constructor")}get view(){if(!IsReadableStreamBYOBRequest(this))throw byobRequestBrandCheckException("view");return this._view}respond(t){if(!IsReadableStreamBYOBRequest(this))throw byobRequestBrandCheckException("respond");if(assertRequiredArgument(t,1,"respond"),t=convertUnsignedLongLongWithEnforceRange(t,"First parameter"),void 0===this._associatedReadableByteStreamController)throw TypeError("This BYOB request has been invalidated");this._view.buffer,ReadableByteStreamControllerRespond(this._associatedReadableByteStreamController,t)}respondWithNewView(t){if(!IsReadableStreamBYOBRequest(this))throw byobRequestBrandCheckException("respondWithNewView");if(assertRequiredArgument(t,1,"respondWithNewView"),!ArrayBuffer.isView(t))throw TypeError("You can only respond with array buffer views");if(void 0===this._associatedReadableByteStreamController)throw TypeError("This BYOB request has been invalidated");t.buffer,ReadableByteStreamControllerRespondWithNewView(this._associatedReadableByteStreamController,t)}};Object.defineProperties(ReadableStreamBYOBRequest.prototype,{respond:{enumerable:!0},respondWithNewView:{enumerable:!0},view:{enumerable:!0}}),"symbol"==typeof r.toStringTag&&Object.defineProperty(ReadableStreamBYOBRequest.prototype,r.toStringTag,{value:"ReadableStreamBYOBRequest",configurable:!0});let ReadableByteStreamController=class ReadableByteStreamController{constructor(){throw TypeError("Illegal constructor")}get byobRequest(){if(!IsReadableByteStreamController(this))throw byteStreamControllerBrandCheckException("byobRequest");return ReadableByteStreamControllerGetBYOBRequest(this)}get desiredSize(){if(!IsReadableByteStreamController(this))throw byteStreamControllerBrandCheckException("desiredSize");return ReadableByteStreamControllerGetDesiredSize(this)}close(){if(!IsReadableByteStreamController(this))throw byteStreamControllerBrandCheckException("close");if(this._closeRequested)throw TypeError("The stream has already been closed; do not close it again!");let t=this._controlledReadableByteStream._state;if("readable"!==t)throw TypeError(`The stream (in ${t} state) is not in the readable state and cannot be closed`);ReadableByteStreamControllerClose(this)}enqueue(t){if(!IsReadableByteStreamController(this))throw byteStreamControllerBrandCheckException("enqueue");if(assertRequiredArgument(t,1,"enqueue"),!ArrayBuffer.isView(t))throw TypeError("chunk must be an array buffer view");if(0===t.byteLength)throw TypeError("chunk must have non-zero byteLength");if(0===t.buffer.byteLength)throw TypeError("chunk's buffer must have non-zero byteLength");if(this._closeRequested)throw TypeError("stream is closed or draining");let r=this._controlledReadableByteStream._state;if("readable"!==r)throw TypeError(`The stream (in ${r} state) is not in the readable state and cannot be enqueued to`);ReadableByteStreamControllerEnqueue(this,t)}error(t){if(!IsReadableByteStreamController(this))throw byteStreamControllerBrandCheckException("error");ReadableByteStreamControllerError(this,t)}[c](t){ReadableByteStreamControllerClearPendingPullIntos(this),ResetQueue(this);let r=this._cancelAlgorithm(t);return ReadableByteStreamControllerClearAlgorithms(this),r}[m](t){let r=this._controlledReadableByteStream;if(this._queueTotalSize>0){let r=this._queue.shift();this._queueTotalSize-=r.byteLength,ReadableByteStreamControllerHandleQueueDrain(this);let a=new Uint8Array(r.buffer,r.byteOffset,r.byteLength);t._chunkSteps(a);return}let a=this._autoAllocateChunkSize;if(void 0!==a){let r;try{r=new ArrayBuffer(a)}catch(r){t._errorSteps(r);return}let o={buffer:r,bufferByteLength:a,byteOffset:0,byteLength:a,bytesFilled:0,elementSize:1,viewConstructor:Uint8Array,readerType:"default"};this._pendingPullIntos.push(o)}ReadableStreamAddReadRequest(r,t),ReadableByteStreamControllerCallPullIfNeeded(this)}};function IsReadableByteStreamController(t){return!!(typeIsObject(t)&&Object.prototype.hasOwnProperty.call(t,"_controlledReadableByteStream"))&&t instanceof ReadableByteStreamController}function IsReadableStreamBYOBRequest(t){return!!(typeIsObject(t)&&Object.prototype.hasOwnProperty.call(t,"_associatedReadableByteStreamController"))&&t instanceof ReadableStreamBYOBRequest}function ReadableByteStreamControllerCallPullIfNeeded(t){let r=function(t){let r=t._controlledReadableByteStream;if("readable"!==r._state||t._closeRequested||!t._started)return!1;if(ReadableStreamHasDefaultReader(r)&&ReadableStreamGetNumReadRequests(r)>0||ReadableStreamHasBYOBReader(r)&&ReadableStreamGetNumReadIntoRequests(r)>0)return!0;let a=ReadableByteStreamControllerGetDesiredSize(t);return a>0}(t);if(!r)return;if(t._pulling){t._pullAgain=!0;return}t._pulling=!0;let a=t._pullAlgorithm();uponPromise(a,()=>{t._pulling=!1,t._pullAgain&&(t._pullAgain=!1,ReadableByteStreamControllerCallPullIfNeeded(t))},r=>{ReadableByteStreamControllerError(t,r)})}function ReadableByteStreamControllerClearPendingPullIntos(t){ReadableByteStreamControllerInvalidateBYOBRequest(t),t._pendingPullIntos=new SimpleQueue}function ReadableByteStreamControllerCommitPullIntoDescriptor(t,r){let a=!1;"closed"===t._state&&(a=!0);let o=ReadableByteStreamControllerConvertPullIntoDescriptor(r);"default"===r.readerType?ReadableStreamFulfillReadRequest(t,o,a):function(t,r,a){let o=t._reader,l=o._readIntoRequests.shift();a?l._closeSteps(r):l._chunkSteps(r)}(t,o,a)}function ReadableByteStreamControllerConvertPullIntoDescriptor(t){let r=t.bytesFilled,a=t.elementSize;return new t.viewConstructor(t.buffer,t.byteOffset,r/a)}function ReadableByteStreamControllerEnqueueChunkToQueue(t,r,a,o){t._queue.push({buffer:r,byteOffset:a,byteLength:o}),t._queueTotalSize+=o}function ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(t,r){let a=r.elementSize,o=r.bytesFilled-r.bytesFilled%a,l=Math.min(t._queueTotalSize,r.byteLength-r.bytesFilled),n=r.bytesFilled+l,i=n-n%a,s=l,u=!1;i>o&&(s=i-r.bytesFilled,u=!0);let d=t._queue;for(;s>0;){let a=d.peek(),o=Math.min(s,a.byteLength),l=r.byteOffset+r.bytesFilled;CopyDataBlockBytes(r.buffer,l,a.buffer,a.byteOffset,o),a.byteLength===o?d.shift():(a.byteOffset+=o,a.byteLength-=o),t._queueTotalSize-=o,ReadableByteStreamControllerFillHeadPullIntoDescriptor(t,o,r),s-=o}return u}function ReadableByteStreamControllerFillHeadPullIntoDescriptor(t,r,a){a.bytesFilled+=r}function ReadableByteStreamControllerHandleQueueDrain(t){0===t._queueTotalSize&&t._closeRequested?(ReadableByteStreamControllerClearAlgorithms(t),ReadableStreamClose(t._controlledReadableByteStream)):ReadableByteStreamControllerCallPullIfNeeded(t)}function ReadableByteStreamControllerInvalidateBYOBRequest(t){null!==t._byobRequest&&(t._byobRequest._associatedReadableByteStreamController=void 0,t._byobRequest._view=null,t._byobRequest=null)}function ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(t){for(;t._pendingPullIntos.length>0;){if(0===t._queueTotalSize)return;let r=t._pendingPullIntos.peek();ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(t,r)&&(ReadableByteStreamControllerShiftPendingPullInto(t),ReadableByteStreamControllerCommitPullIntoDescriptor(t._controlledReadableByteStream,r))}}function ReadableByteStreamControllerRespondInternal(t,r){let a=t._pendingPullIntos.peek();ReadableByteStreamControllerInvalidateBYOBRequest(t);let o=t._controlledReadableByteStream._state;"closed"===o?function(t,r){let a=t._controlledReadableByteStream;if(ReadableStreamHasBYOBReader(a))for(;ReadableStreamGetNumReadIntoRequests(a)>0;){let r=ReadableByteStreamControllerShiftPendingPullInto(t);ReadableByteStreamControllerCommitPullIntoDescriptor(a,r)}}(t):function(t,r,a){if(ReadableByteStreamControllerFillHeadPullIntoDescriptor(t,r,a),a.bytesFilled<a.elementSize)return;ReadableByteStreamControllerShiftPendingPullInto(t);let o=a.bytesFilled%a.elementSize;if(o>0){let r=a.byteOffset+a.bytesFilled,l=ArrayBufferSlice(a.buffer,r-o,r);ReadableByteStreamControllerEnqueueChunkToQueue(t,l,0,l.byteLength)}a.bytesFilled-=o,ReadableByteStreamControllerCommitPullIntoDescriptor(t._controlledReadableByteStream,a),ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(t)}(t,r,a),ReadableByteStreamControllerCallPullIfNeeded(t)}function ReadableByteStreamControllerShiftPendingPullInto(t){let r=t._pendingPullIntos.shift();return r}function ReadableByteStreamControllerClearAlgorithms(t){t._pullAlgorithm=void 0,t._cancelAlgorithm=void 0}function ReadableByteStreamControllerClose(t){let r=t._controlledReadableByteStream;if(!t._closeRequested&&"readable"===r._state){if(t._queueTotalSize>0){t._closeRequested=!0;return}if(t._pendingPullIntos.length>0){let r=t._pendingPullIntos.peek();if(r.bytesFilled>0){let r=TypeError("Insufficient bytes to fill elements in the given buffer");throw ReadableByteStreamControllerError(t,r),r}}ReadableByteStreamControllerClearAlgorithms(t),ReadableStreamClose(r)}}function ReadableByteStreamControllerEnqueue(t,r){let a=t._controlledReadableByteStream;if(t._closeRequested||"readable"!==a._state)return;let o=r.buffer,l=r.byteOffset,n=r.byteLength;if(t._pendingPullIntos.length>0){let r=t._pendingPullIntos.peek();r.buffer,r.buffer=r.buffer}if(ReadableByteStreamControllerInvalidateBYOBRequest(t),ReadableStreamHasDefaultReader(a)){if(0===ReadableStreamGetNumReadRequests(a))ReadableByteStreamControllerEnqueueChunkToQueue(t,o,l,n);else{t._pendingPullIntos.length>0&&ReadableByteStreamControllerShiftPendingPullInto(t);let r=new Uint8Array(o,l,n);ReadableStreamFulfillReadRequest(a,r,!1)}}else ReadableStreamHasBYOBReader(a)?(ReadableByteStreamControllerEnqueueChunkToQueue(t,o,l,n),ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(t)):ReadableByteStreamControllerEnqueueChunkToQueue(t,o,l,n);ReadableByteStreamControllerCallPullIfNeeded(t)}function ReadableByteStreamControllerError(t,r){let a=t._controlledReadableByteStream;"readable"===a._state&&(ReadableByteStreamControllerClearPendingPullIntos(t),ResetQueue(t),ReadableByteStreamControllerClearAlgorithms(t),ReadableStreamError(a,r))}function ReadableByteStreamControllerGetBYOBRequest(t){if(null===t._byobRequest&&t._pendingPullIntos.length>0){let r=t._pendingPullIntos.peek(),a=new Uint8Array(r.buffer,r.byteOffset+r.bytesFilled,r.byteLength-r.bytesFilled),o=Object.create(ReadableStreamBYOBRequest.prototype);o._associatedReadableByteStreamController=t,o._view=a,t._byobRequest=o}return t._byobRequest}function ReadableByteStreamControllerGetDesiredSize(t){let r=t._controlledReadableByteStream._state;return"errored"===r?null:"closed"===r?0:t._strategyHWM-t._queueTotalSize}function ReadableByteStreamControllerRespond(t,r){let a=t._pendingPullIntos.peek(),o=t._controlledReadableByteStream._state;if("closed"===o){if(0!==r)throw TypeError("bytesWritten must be 0 when calling respond() on a closed stream")}else{if(0===r)throw TypeError("bytesWritten must be greater than 0 when calling respond() on a readable stream");if(a.bytesFilled+r>a.byteLength)throw RangeError("bytesWritten out of range")}a.buffer=a.buffer,ReadableByteStreamControllerRespondInternal(t,r)}function ReadableByteStreamControllerRespondWithNewView(t,r){let a=t._pendingPullIntos.peek(),o=t._controlledReadableByteStream._state;if("closed"===o){if(0!==r.byteLength)throw TypeError("The view's length must be 0 when calling respondWithNewView() on a closed stream")}else if(0===r.byteLength)throw TypeError("The view's length must be greater than 0 when calling respondWithNewView() on a readable stream");if(a.byteOffset+a.bytesFilled!==r.byteOffset)throw RangeError("The region specified by view does not match byobRequest");if(a.bufferByteLength!==r.buffer.byteLength)throw RangeError("The buffer of view has different capacity than byobRequest");if(a.bytesFilled+r.byteLength>a.byteLength)throw RangeError("The region specified by view is larger than byobRequest");let l=r.byteLength;a.buffer=r.buffer,ReadableByteStreamControllerRespondInternal(t,l)}function SetUpReadableByteStreamController(t,r,a,o,l,i,s){r._controlledReadableByteStream=t,r._pullAgain=!1,r._pulling=!1,r._byobRequest=null,r._queue=r._queueTotalSize=void 0,ResetQueue(r),r._closeRequested=!1,r._started=!1,r._strategyHWM=i,r._pullAlgorithm=o,r._cancelAlgorithm=l,r._autoAllocateChunkSize=s,r._pendingPullIntos=new SimpleQueue,t._readableStreamController=r;let u=a();uponPromise(n(u),()=>{r._started=!0,ReadableByteStreamControllerCallPullIfNeeded(r)},t=>{ReadableByteStreamControllerError(r,t)})}function byobRequestBrandCheckException(t){return TypeError(`ReadableStreamBYOBRequest.prototype.${t} can only be used on a ReadableStreamBYOBRequest`)}function byteStreamControllerBrandCheckException(t){return TypeError(`ReadableByteStreamController.prototype.${t} can only be used on a ReadableByteStreamController`)}function ReadableStreamAddReadIntoRequest(t,r){t._reader._readIntoRequests.push(r)}function ReadableStreamGetNumReadIntoRequests(t){return t._reader._readIntoRequests.length}function ReadableStreamHasBYOBReader(t){let r=t._reader;return!!(void 0!==r&&IsReadableStreamBYOBReader(r))}Object.defineProperties(ReadableByteStreamController.prototype,{close:{enumerable:!0},enqueue:{enumerable:!0},error:{enumerable:!0},byobRequest:{enumerable:!0},desiredSize:{enumerable:!0}}),"symbol"==typeof r.toStringTag&&Object.defineProperty(ReadableByteStreamController.prototype,r.toStringTag,{value:"ReadableByteStreamController",configurable:!0});let ReadableStreamBYOBReader=class ReadableStreamBYOBReader{constructor(t){if(assertRequiredArgument(t,1,"ReadableStreamBYOBReader"),assertReadableStream(t,"First parameter"),IsReadableStreamLocked(t))throw TypeError("This stream has already been locked for exclusive reading by another reader");if(!IsReadableByteStreamController(t._readableStreamController))throw TypeError("Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte source");ReadableStreamReaderGenericInitialize(this,t),this._readIntoRequests=new SimpleQueue}get closed(){return IsReadableStreamBYOBReader(this)?this._closedPromise:i(byobReaderBrandCheckException("closed"))}cancel(t){return IsReadableStreamBYOBReader(this)?void 0===this._ownerReadableStream?i(readerLockException("cancel")):ReadableStreamReaderGenericCancel(this,t):i(byobReaderBrandCheckException("cancel"))}read(t){let r,a;if(!IsReadableStreamBYOBReader(this))return i(byobReaderBrandCheckException("read"));if(!ArrayBuffer.isView(t))return i(TypeError("view must be an array buffer view"));if(0===t.byteLength)return i(TypeError("view must have non-zero byteLength"));if(0===t.buffer.byteLength)return i(TypeError("view's buffer must have non-zero byteLength"));if(t.buffer,void 0===this._ownerReadableStream)return i(readerLockException("read from"));let o=newPromise((t,o)=>{r=t,a=o});return ReadableStreamBYOBReaderRead(this,t,{_chunkSteps:t=>r({value:t,done:!1}),_closeSteps:t=>r({value:t,done:!0}),_errorSteps:t=>a(t)}),o}releaseLock(){if(!IsReadableStreamBYOBReader(this))throw byobReaderBrandCheckException("releaseLock");if(void 0!==this._ownerReadableStream){if(this._readIntoRequests.length>0)throw TypeError("Tried to release a reader lock when that reader has pending read() calls un-settled");ReadableStreamReaderGenericRelease(this)}}};function IsReadableStreamBYOBReader(t){return!!(typeIsObject(t)&&Object.prototype.hasOwnProperty.call(t,"_readIntoRequests"))&&t instanceof ReadableStreamBYOBReader}function ReadableStreamBYOBReaderRead(t,r,a){let o=t._ownerReadableStream;o._disturbed=!0,"errored"===o._state?a._errorSteps(o._storedError):function(t,r,a){let o=t._controlledReadableByteStream,l=1;r.constructor!==DataView&&(l=r.constructor.BYTES_PER_ELEMENT);let n=r.constructor,i=r.buffer,s={buffer:i,bufferByteLength:i.byteLength,byteOffset:r.byteOffset,byteLength:r.byteLength,bytesFilled:0,elementSize:l,viewConstructor:n,readerType:"byob"};if(t._pendingPullIntos.length>0){t._pendingPullIntos.push(s),ReadableStreamAddReadIntoRequest(o,a);return}if("closed"===o._state){let t=new n(s.buffer,s.byteOffset,0);a._closeSteps(t);return}if(t._queueTotalSize>0){if(ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(t,s)){let r=ReadableByteStreamControllerConvertPullIntoDescriptor(s);ReadableByteStreamControllerHandleQueueDrain(t),a._chunkSteps(r);return}if(t._closeRequested){let r=TypeError("Insufficient bytes to fill elements in the given buffer");ReadableByteStreamControllerError(t,r),a._errorSteps(r);return}}t._pendingPullIntos.push(s),ReadableStreamAddReadIntoRequest(o,a),ReadableByteStreamControllerCallPullIfNeeded(t)}(o._readableStreamController,r,a)}function byobReaderBrandCheckException(t){return TypeError(`ReadableStreamBYOBReader.prototype.${t} can only be used on a ReadableStreamBYOBReader`)}function ExtractHighWaterMark(t,r){let{highWaterMark:a}=t;if(void 0===a)return r;if(S(a)||a<0)throw RangeError("Invalid highWaterMark");return a}function ExtractSizeAlgorithm(t){let{size:r}=t;return r||(()=>1)}function convertQueuingStrategy(t,r){assertDictionary(t,r);let a=null==t?void 0:t.highWaterMark,o=null==t?void 0:t.size;return{highWaterMark:void 0===a?void 0:convertUnrestrictedDouble(a),size:void 0===o?void 0:(assertFunction(o,`${r} has member 'size' that`),t=>convertUnrestrictedDouble(o(t)))}}function assertWritableStream(t,r){if(!IsWritableStream(t))throw TypeError(`${r} is not a WritableStream.`)}Object.defineProperties(ReadableStreamBYOBReader.prototype,{cancel:{enumerable:!0},read:{enumerable:!0},releaseLock:{enumerable:!0},closed:{enumerable:!0}}),"symbol"==typeof r.toStringTag&&Object.defineProperty(ReadableStreamBYOBReader.prototype,r.toStringTag,{value:"ReadableStreamBYOBReader",configurable:!0});let R="function"==typeof AbortController;let WritableStream=class WritableStream{constructor(t={},r={}){void 0===t?t=null:assertObject(t,"First parameter");let a=convertQueuingStrategy(r,"Second parameter"),o=function(t,r){assertDictionary(t,r);let a=null==t?void 0:t.abort,o=null==t?void 0:t.close,l=null==t?void 0:t.start,n=null==t?void 0:t.type,i=null==t?void 0:t.write;return{abort:void 0===a?void 0:(assertFunction(a,`${r} has member 'abort' that`),r=>promiseCall(a,t,[r])),close:void 0===o?void 0:(assertFunction(o,`${r} has member 'close' that`),()=>promiseCall(o,t,[])),start:void 0===l?void 0:(assertFunction(l,`${r} has member 'start' that`),r=>reflectCall(l,t,[r])),write:void 0===i?void 0:(assertFunction(i,`${r} has member 'write' that`),(r,a)=>promiseCall(i,t,[r,a])),type:n}}(t,"First parameter");InitializeWritableStream(this);let l=o.type;if(void 0!==l)throw RangeError("Invalid type is specified");let i=ExtractSizeAlgorithm(a),s=ExtractHighWaterMark(a,1);(function(t,r,a,o){let l=Object.create(WritableStreamDefaultController.prototype),startAlgorithm=()=>void 0,writeAlgorithm=()=>n(void 0),closeAlgorithm=()=>n(void 0),abortAlgorithm=()=>n(void 0);void 0!==r.start&&(startAlgorithm=()=>r.start(l)),void 0!==r.write&&(writeAlgorithm=t=>r.write(t,l)),void 0!==r.close&&(closeAlgorithm=()=>r.close()),void 0!==r.abort&&(abortAlgorithm=t=>r.abort(t)),SetUpWritableStreamDefaultController(t,l,startAlgorithm,writeAlgorithm,closeAlgorithm,abortAlgorithm,a,o)})(this,o,s,i)}get locked(){if(!IsWritableStream(this))throw streamBrandCheckException$2("locked");return IsWritableStreamLocked(this)}abort(t){return IsWritableStream(this)?IsWritableStreamLocked(this)?i(TypeError("Cannot abort a stream that already has a writer")):WritableStreamAbort(this,t):i(streamBrandCheckException$2("abort"))}close(){return IsWritableStream(this)?IsWritableStreamLocked(this)?i(TypeError("Cannot close a stream that already has a writer")):WritableStreamCloseQueuedOrInFlight(this)?i(TypeError("Cannot close an already-closing stream")):WritableStreamClose(this):i(streamBrandCheckException$2("close"))}getWriter(){if(!IsWritableStream(this))throw streamBrandCheckException$2("getWriter");return new WritableStreamDefaultWriter(this)}};function InitializeWritableStream(t){t._state="writable",t._storedError=void 0,t._writer=void 0,t._writableStreamController=void 0,t._writeRequests=new SimpleQueue,t._inFlightWriteRequest=void 0,t._closeRequest=void 0,t._inFlightCloseRequest=void 0,t._pendingAbortRequest=void 0,t._backpressure=!1}function IsWritableStream(t){return!!(typeIsObject(t)&&Object.prototype.hasOwnProperty.call(t,"_writableStreamController"))&&t instanceof WritableStream}function IsWritableStreamLocked(t){return void 0!==t._writer}function WritableStreamAbort(t,r){var a;if("closed"===t._state||"errored"===t._state)return n(void 0);t._writableStreamController._abortReason=r,null===(a=t._writableStreamController._abortController)||void 0===a||a.abort();let o=t._state;if("closed"===o||"errored"===o)return n(void 0);if(void 0!==t._pendingAbortRequest)return t._pendingAbortRequest._promise;let l=!1;"erroring"===o&&(l=!0,r=void 0);let i=newPromise((a,o)=>{t._pendingAbortRequest={_promise:void 0,_resolve:a,_reject:o,_reason:r,_wasAlreadyErroring:l}});return t._pendingAbortRequest._promise=i,l||WritableStreamStartErroring(t,r),i}function WritableStreamClose(t){var r;let a=t._state;if("closed"===a||"errored"===a)return i(TypeError(`The stream (in ${a} state) is not in the writable state and cannot be closed`));let o=newPromise((r,a)=>{t._closeRequest={_resolve:r,_reject:a}}),l=t._writer;return void 0!==l&&t._backpressure&&"writable"===a&&defaultWriterReadyPromiseResolve(l),EnqueueValueWithSize(r=t._writableStreamController,g,0),WritableStreamDefaultControllerAdvanceQueueIfNeeded(r),o}function WritableStreamDealWithRejection(t,r){let a=t._state;if("writable"===a){WritableStreamStartErroring(t,r);return}WritableStreamFinishErroring(t)}function WritableStreamStartErroring(t,r){let a=t._writableStreamController;t._state="erroring",t._storedError=r;let o=t._writer;void 0!==o&&WritableStreamDefaultWriterEnsureReadyPromiseRejected(o,r),!(void 0!==t._inFlightWriteRequest||void 0!==t._inFlightCloseRequest)&&a._started&&WritableStreamFinishErroring(t)}function WritableStreamFinishErroring(t){t._state="errored",t._writableStreamController[d]();let r=t._storedError;if(t._writeRequests.forEach(t=>{t._reject(r)}),t._writeRequests=new SimpleQueue,void 0===t._pendingAbortRequest){WritableStreamRejectCloseAndClosedPromiseIfNeeded(t);return}let a=t._pendingAbortRequest;if(t._pendingAbortRequest=void 0,a._wasAlreadyErroring){a._reject(r),WritableStreamRejectCloseAndClosedPromiseIfNeeded(t);return}let o=t._writableStreamController[u](a._reason);uponPromise(o,()=>{a._resolve(),WritableStreamRejectCloseAndClosedPromiseIfNeeded(t)},r=>{a._reject(r),WritableStreamRejectCloseAndClosedPromiseIfNeeded(t)})}function WritableStreamCloseQueuedOrInFlight(t){return void 0!==t._closeRequest||void 0!==t._inFlightCloseRequest}function WritableStreamRejectCloseAndClosedPromiseIfNeeded(t){void 0!==t._closeRequest&&(t._closeRequest._reject(t._storedError),t._closeRequest=void 0);let r=t._writer;void 0!==r&&defaultWriterClosedPromiseReject(r,t._storedError)}function WritableStreamUpdateBackpressure(t,r){let a=t._writer;void 0!==a&&r!==t._backpressure&&(r?defaultWriterReadyPromiseInitialize(a):defaultWriterReadyPromiseResolve(a)),t._backpressure=r}Object.defineProperties(WritableStream.prototype,{abort:{enumerable:!0},close:{enumerable:!0},getWriter:{enumerable:!0},locked:{enumerable:!0}}),"symbol"==typeof r.toStringTag&&Object.defineProperty(WritableStream.prototype,r.toStringTag,{value:"WritableStream",configurable:!0});let WritableStreamDefaultWriter=class WritableStreamDefaultWriter{constructor(t){if(assertRequiredArgument(t,1,"WritableStreamDefaultWriter"),assertWritableStream(t,"First parameter"),IsWritableStreamLocked(t))throw TypeError("This stream has already been locked for exclusive writing by another writer");this._ownerWritableStream=t,t._writer=this;let r=t._state;if("writable"===r)!WritableStreamCloseQueuedOrInFlight(t)&&t._backpressure?defaultWriterReadyPromiseInitialize(this):(defaultWriterReadyPromiseInitialize(this),defaultWriterReadyPromiseResolve(this)),defaultWriterClosedPromiseInitialize(this);else if("erroring"===r)defaultWriterReadyPromiseInitializeAsRejected(this,t._storedError),defaultWriterClosedPromiseInitialize(this);else if("closed"===r)defaultWriterReadyPromiseInitialize(this),defaultWriterReadyPromiseResolve(this),defaultWriterClosedPromiseInitialize(this),defaultWriterClosedPromiseResolve(this);else{let r=t._storedError;defaultWriterReadyPromiseInitializeAsRejected(this,r),defaultWriterClosedPromiseInitialize(this),defaultWriterClosedPromiseReject(this,r)}}get closed(){return IsWritableStreamDefaultWriter(this)?this._closedPromise:i(defaultWriterBrandCheckException("closed"))}get desiredSize(){if(!IsWritableStreamDefaultWriter(this))throw defaultWriterBrandCheckException("desiredSize");if(void 0===this._ownerWritableStream)throw defaultWriterLockException("desiredSize");return function(t){let r=t._ownerWritableStream,a=r._state;return"errored"===a||"erroring"===a?null:"closed"===a?0:WritableStreamDefaultControllerGetDesiredSize(r._writableStreamController)}(this)}get ready(){return IsWritableStreamDefaultWriter(this)?this._readyPromise:i(defaultWriterBrandCheckException("ready"))}abort(t){return IsWritableStreamDefaultWriter(this)?void 0===this._ownerWritableStream?i(defaultWriterLockException("abort")):function(t,r){let a=t._ownerWritableStream;return WritableStreamAbort(a,r)}(this,t):i(defaultWriterBrandCheckException("abort"))}close(){if(!IsWritableStreamDefaultWriter(this))return i(defaultWriterBrandCheckException("close"));let t=this._ownerWritableStream;return void 0===t?i(defaultWriterLockException("close")):WritableStreamCloseQueuedOrInFlight(t)?i(TypeError("Cannot close an already-closing stream")):WritableStreamDefaultWriterClose(this)}releaseLock(){if(!IsWritableStreamDefaultWriter(this))throw defaultWriterBrandCheckException("releaseLock");let t=this._ownerWritableStream;void 0!==t&&WritableStreamDefaultWriterRelease(this)}write(t){return IsWritableStreamDefaultWriter(this)?void 0===this._ownerWritableStream?i(defaultWriterLockException("write to")):WritableStreamDefaultWriterWrite(this,t):i(defaultWriterBrandCheckException("write"))}};function IsWritableStreamDefaultWriter(t){return!!(typeIsObject(t)&&Object.prototype.hasOwnProperty.call(t,"_ownerWritableStream"))&&t instanceof WritableStreamDefaultWriter}function WritableStreamDefaultWriterClose(t){let r=t._ownerWritableStream;return WritableStreamClose(r)}function WritableStreamDefaultWriterEnsureReadyPromiseRejected(t,r){"pending"===t._readyPromiseState?defaultWriterReadyPromiseReject(t,r):defaultWriterReadyPromiseInitializeAsRejected(t,r)}function WritableStreamDefaultWriterRelease(t){var r,a;let o=t._ownerWritableStream,l=TypeError("Writer was released and can no longer be used to monitor the stream's closedness");WritableStreamDefaultWriterEnsureReadyPromiseRejected(t,l),"pending"===t._closedPromiseState?defaultWriterClosedPromiseReject(t,l):(r=t,a=l,defaultWriterClosedPromiseInitialize(r),defaultWriterClosedPromiseReject(r,a)),o._writer=void 0,t._ownerWritableStream=void 0}function WritableStreamDefaultWriterWrite(t,r){let a=t._ownerWritableStream,o=a._writableStreamController,l=function(t,r){try{return t._strategySizeAlgorithm(r)}catch(r){return WritableStreamDefaultControllerErrorIfNeeded(t,r),1}}(o,r);if(a!==t._ownerWritableStream)return i(defaultWriterLockException("write to"));let n=a._state;if("errored"===n)return i(a._storedError);if(WritableStreamCloseQueuedOrInFlight(a)||"closed"===n)return i(TypeError("The stream is closing or closed and cannot be written to"));if("erroring"===n)return i(a._storedError);let s=function(t){let r=newPromise((r,a)=>{t._writeRequests.push({_resolve:r,_reject:a})});return r}(a);return function(t,r,a){try{EnqueueValueWithSize(t,r,a)}catch(r){WritableStreamDefaultControllerErrorIfNeeded(t,r);return}let o=t._controlledWritableStream;if(!WritableStreamCloseQueuedOrInFlight(o)&&"writable"===o._state){let r=WritableStreamDefaultControllerGetBackpressure(t);WritableStreamUpdateBackpressure(o,r)}WritableStreamDefaultControllerAdvanceQueueIfNeeded(t)}(o,r,l),s}Object.defineProperties(WritableStreamDefaultWriter.prototype,{abort:{enumerable:!0},close:{enumerable:!0},releaseLock:{enumerable:!0},write:{enumerable:!0},closed:{enumerable:!0},desiredSize:{enumerable:!0},ready:{enumerable:!0}}),"symbol"==typeof r.toStringTag&&Object.defineProperty(WritableStreamDefaultWriter.prototype,r.toStringTag,{value:"WritableStreamDefaultWriter",configurable:!0});let g={};let WritableStreamDefaultController=class WritableStreamDefaultController{constructor(){throw TypeError("Illegal constructor")}get abortReason(){if(!IsWritableStreamDefaultController(this))throw defaultControllerBrandCheckException$2("abortReason");return this._abortReason}get signal(){if(!IsWritableStreamDefaultController(this))throw defaultControllerBrandCheckException$2("signal");if(void 0===this._abortController)throw TypeError("WritableStreamDefaultController.prototype.signal is not supported");return this._abortController.signal}error(t){if(!IsWritableStreamDefaultController(this))throw defaultControllerBrandCheckException$2("error");let r=this._controlledWritableStream._state;"writable"===r&&WritableStreamDefaultControllerError(this,t)}[u](t){let r=this._abortAlgorithm(t);return WritableStreamDefaultControllerClearAlgorithms(this),r}[d](){ResetQueue(this)}};function IsWritableStreamDefaultController(t){return!!(typeIsObject(t)&&Object.prototype.hasOwnProperty.call(t,"_controlledWritableStream"))&&t instanceof WritableStreamDefaultController}function SetUpWritableStreamDefaultController(t,r,a,o,l,i,s,u){r._controlledWritableStream=t,t._writableStreamController=r,r._queue=void 0,r._queueTotalSize=void 0,ResetQueue(r),r._abortReason=void 0,r._abortController=function(){if(R)return new AbortController}(),r._started=!1,r._strategySizeAlgorithm=u,r._strategyHWM=s,r._writeAlgorithm=o,r._closeAlgorithm=l,r._abortAlgorithm=i;let d=WritableStreamDefaultControllerGetBackpressure(r);WritableStreamUpdateBackpressure(t,d);let c=a(),m=n(c);uponPromise(m,()=>{r._started=!0,WritableStreamDefaultControllerAdvanceQueueIfNeeded(r)},a=>{r._started=!0,WritableStreamDealWithRejection(t,a)})}function WritableStreamDefaultControllerClearAlgorithms(t){t._writeAlgorithm=void 0,t._closeAlgorithm=void 0,t._abortAlgorithm=void 0,t._strategySizeAlgorithm=void 0}function WritableStreamDefaultControllerGetDesiredSize(t){return t._strategyHWM-t._queueTotalSize}function WritableStreamDefaultControllerAdvanceQueueIfNeeded(t){let r=t._controlledWritableStream;if(!t._started||void 0!==r._inFlightWriteRequest)return;let a=r._state;if("erroring"===a){WritableStreamFinishErroring(r);return}if(0===t._queue.length)return;let o=function(t){let r=t._queue.peek();return r.value}(t);o===g?function(t){let r=t._controlledWritableStream;r._inFlightCloseRequest=r._closeRequest,r._closeRequest=void 0,DequeueValue(t);let a=t._closeAlgorithm();WritableStreamDefaultControllerClearAlgorithms(t),uponPromise(a,()=>{!function(t){t._inFlightCloseRequest._resolve(void 0),t._inFlightCloseRequest=void 0;let r=t._state;"erroring"===r&&(t._storedError=void 0,void 0!==t._pendingAbortRequest&&(t._pendingAbortRequest._resolve(),t._pendingAbortRequest=void 0)),t._state="closed";let a=t._writer;void 0!==a&&defaultWriterClosedPromiseResolve(a)}(r)},t=>{r._inFlightCloseRequest._reject(t),r._inFlightCloseRequest=void 0,void 0!==r._pendingAbortRequest&&(r._pendingAbortRequest._reject(t),r._pendingAbortRequest=void 0),WritableStreamDealWithRejection(r,t)})}(t):function(t,r){let a=t._controlledWritableStream;a._inFlightWriteRequest=a._writeRequests.shift();let o=t._writeAlgorithm(r);uponPromise(o,()=>{a._inFlightWriteRequest._resolve(void 0),a._inFlightWriteRequest=void 0;let r=a._state;if(DequeueValue(t),!WritableStreamCloseQueuedOrInFlight(a)&&"writable"===r){let r=WritableStreamDefaultControllerGetBackpressure(t);WritableStreamUpdateBackpressure(a,r)}WritableStreamDefaultControllerAdvanceQueueIfNeeded(t)},r=>{"writable"===a._state&&WritableStreamDefaultControllerClearAlgorithms(t),a._inFlightWriteRequest._reject(r),a._inFlightWriteRequest=void 0,WritableStreamDealWithRejection(a,r)})}(t,o)}function WritableStreamDefaultControllerErrorIfNeeded(t,r){"writable"===t._controlledWritableStream._state&&WritableStreamDefaultControllerError(t,r)}function WritableStreamDefaultControllerGetBackpressure(t){let r=WritableStreamDefaultControllerGetDesiredSize(t);return r<=0}function WritableStreamDefaultControllerError(t,r){let a=t._controlledWritableStream;WritableStreamDefaultControllerClearAlgorithms(t),WritableStreamStartErroring(a,r)}function streamBrandCheckException$2(t){return TypeError(`WritableStream.prototype.${t} can only be used on a WritableStream`)}function defaultControllerBrandCheckException$2(t){return TypeError(`WritableStreamDefaultController.prototype.${t} can only be used on a WritableStreamDefaultController`)}function defaultWriterBrandCheckException(t){return TypeError(`WritableStreamDefaultWriter.prototype.${t} can only be used on a WritableStreamDefaultWriter`)}function defaultWriterLockException(t){return TypeError("Cannot "+t+" a stream using a released writer")}function defaultWriterClosedPromiseInitialize(t){t._closedPromise=newPromise((r,a)=>{t._closedPromise_resolve=r,t._closedPromise_reject=a,t._closedPromiseState="pending"})}function defaultWriterClosedPromiseReject(t,r){void 0!==t._closedPromise_reject&&(setPromiseIsHandledToTrue(t._closedPromise),t._closedPromise_reject(r),t._closedPromise_resolve=void 0,t._closedPromise_reject=void 0,t._closedPromiseState="rejected")}function defaultWriterClosedPromiseResolve(t){void 0!==t._closedPromise_resolve&&(t._closedPromise_resolve(void 0),t._closedPromise_resolve=void 0,t._closedPromise_reject=void 0,t._closedPromiseState="resolved")}function defaultWriterReadyPromiseInitialize(t){t._readyPromise=newPromise((r,a)=>{t._readyPromise_resolve=r,t._readyPromise_reject=a}),t._readyPromiseState="pending"}function defaultWriterReadyPromiseInitializeAsRejected(t,r){defaultWriterReadyPromiseInitialize(t),defaultWriterReadyPromiseReject(t,r)}function defaultWriterReadyPromiseReject(t,r){void 0!==t._readyPromise_reject&&(setPromiseIsHandledToTrue(t._readyPromise),t._readyPromise_reject(r),t._readyPromise_resolve=void 0,t._readyPromise_reject=void 0,t._readyPromiseState="rejected")}function defaultWriterReadyPromiseResolve(t){void 0!==t._readyPromise_resolve&&(t._readyPromise_resolve(void 0),t._readyPromise_resolve=void 0,t._readyPromise_reject=void 0,t._readyPromiseState="fulfilled")}Object.defineProperties(WritableStreamDefaultController.prototype,{abortReason:{enumerable:!0},signal:{enumerable:!0},error:{enumerable:!0}}),"symbol"==typeof r.toStringTag&&Object.defineProperty(WritableStreamDefaultController.prototype,r.toStringTag,{value:"WritableStreamDefaultController",configurable:!0});let _="undefined"!=typeof DOMException?DOMException:void 0,C=!function(t){if(!("function"==typeof t||"object"==typeof t))return!1;try{return new t,!0}catch(t){return!1}}(_)?function(){let ctor=function(t,r){this.message=t||"",this.name=r||"Error",Error.captureStackTrace&&Error.captureStackTrace(this,this.constructor)};return ctor.prototype=Object.create(Error.prototype),Object.defineProperty(ctor.prototype,"constructor",{value:ctor,writable:!0,configurable:!0}),ctor}():_;function ReadableStreamPipeTo(t,r,a,o,l,s){let u=AcquireReadableStreamDefaultReader(t),d=new WritableStreamDefaultWriter(r);t._disturbed=!0;let c=!1,m=n(void 0);return newPromise((b,h)=>{var p,y;let S;if(void 0!==s){if(S=()=>{let a=new C("Aborted","AbortError"),i=[];o||i.push(()=>"writable"===r._state?WritableStreamAbort(r,a):n(void 0)),l||i.push(()=>"readable"===t._state?ReadableStreamCancel(t,a):n(void 0)),shutdownWithAction(()=>Promise.all(i.map(t=>t())),!0,a)},s.aborted){S();return}s.addEventListener("abort",S)}if(isOrBecomesErrored(t,u._closedPromise,t=>{o?shutdown(!0,t):shutdownWithAction(()=>WritableStreamAbort(r,t),!0,t)}),isOrBecomesErrored(r,d._closedPromise,r=>{l?shutdown(!0,r):shutdownWithAction(()=>ReadableStreamCancel(t,r),!0,r)}),p=u._closedPromise,y=()=>{a?shutdown():shutdownWithAction(()=>(function(t){let r=t._ownerWritableStream,a=r._state;return WritableStreamCloseQueuedOrInFlight(r)||"closed"===a?n(void 0):"errored"===a?i(r._storedError):WritableStreamDefaultWriterClose(t)})(d))},"closed"===t._state?y():uponPromise(p,y),WritableStreamCloseQueuedOrInFlight(r)||"closed"===r._state){let r=TypeError("the destination writable stream closed before all data could be piped to it");l?shutdown(!0,r):shutdownWithAction(()=>ReadableStreamCancel(t,r),!0,r)}function waitForWritesToFinish(){let t=m;return PerformPromiseThen(m,()=>t!==m?waitForWritesToFinish():void 0)}function isOrBecomesErrored(t,r,a){"errored"===t._state?a(t._storedError):uponRejection(r,a)}function shutdownWithAction(t,a,o){!c&&((c=!0,"writable"!==r._state||WritableStreamCloseQueuedOrInFlight(r))?doTheRest():uponPromise(waitForWritesToFinish(),doTheRest));function doTheRest(){uponPromise(t(),()=>finalize(a,o),t=>finalize(!0,t))}}function shutdown(t,a){!c&&((c=!0,"writable"!==r._state||WritableStreamCloseQueuedOrInFlight(r))?finalize(t,a):uponPromise(waitForWritesToFinish(),()=>finalize(t,a)))}function finalize(t,r){WritableStreamDefaultWriterRelease(d),ReadableStreamReaderGenericRelease(u),void 0!==s&&s.removeEventListener("abort",S),t?h(r):b(void 0)}setPromiseIsHandledToTrue(newPromise((t,r)=>{!function next(a){a?t():PerformPromiseThen(c?n(!0):PerformPromiseThen(d._readyPromise,()=>newPromise((t,r)=>{ReadableStreamDefaultReaderRead(u,{_chunkSteps:r=>{m=PerformPromiseThen(WritableStreamDefaultWriterWrite(d,r),void 0,noop),t(!1)},_closeSteps:()=>t(!0),_errorSteps:r})})),next,r)}(!1)}))})}let ReadableStreamDefaultController=class ReadableStreamDefaultController{constructor(){throw TypeError("Illegal constructor")}get desiredSize(){if(!IsReadableStreamDefaultController(this))throw defaultControllerBrandCheckException$1("desiredSize");return ReadableStreamDefaultControllerGetDesiredSize(this)}close(){if(!IsReadableStreamDefaultController(this))throw defaultControllerBrandCheckException$1("close");if(!ReadableStreamDefaultControllerCanCloseOrEnqueue(this))throw TypeError("The stream is not in a state that permits close");ReadableStreamDefaultControllerClose(this)}enqueue(t){if(!IsReadableStreamDefaultController(this))throw defaultControllerBrandCheckException$1("enqueue");if(!ReadableStreamDefaultControllerCanCloseOrEnqueue(this))throw TypeError("The stream is not in a state that permits enqueue");return ReadableStreamDefaultControllerEnqueue(this,t)}error(t){if(!IsReadableStreamDefaultController(this))throw defaultControllerBrandCheckException$1("error");ReadableStreamDefaultControllerError(this,t)}[c](t){ResetQueue(this);let r=this._cancelAlgorithm(t);return ReadableStreamDefaultControllerClearAlgorithms(this),r}[m](t){let r=this._controlledReadableStream;if(this._queue.length>0){let a=DequeueValue(this);this._closeRequested&&0===this._queue.length?(ReadableStreamDefaultControllerClearAlgorithms(this),ReadableStreamClose(r)):ReadableStreamDefaultControllerCallPullIfNeeded(this),t._chunkSteps(a)}else ReadableStreamAddReadRequest(r,t),ReadableStreamDefaultControllerCallPullIfNeeded(this)}};function IsReadableStreamDefaultController(t){return!!(typeIsObject(t)&&Object.prototype.hasOwnProperty.call(t,"_controlledReadableStream"))&&t instanceof ReadableStreamDefaultController}function ReadableStreamDefaultControllerCallPullIfNeeded(t){let r=ReadableStreamDefaultControllerShouldCallPull(t);if(!r)return;if(t._pulling){t._pullAgain=!0;return}t._pulling=!0;let a=t._pullAlgorithm();uponPromise(a,()=>{t._pulling=!1,t._pullAgain&&(t._pullAgain=!1,ReadableStreamDefaultControllerCallPullIfNeeded(t))},r=>{ReadableStreamDefaultControllerError(t,r)})}function ReadableStreamDefaultControllerShouldCallPull(t){let r=t._controlledReadableStream;if(!ReadableStreamDefaultControllerCanCloseOrEnqueue(t)||!t._started)return!1;if(IsReadableStreamLocked(r)&&ReadableStreamGetNumReadRequests(r)>0)return!0;let a=ReadableStreamDefaultControllerGetDesiredSize(t);return a>0}function ReadableStreamDefaultControllerClearAlgorithms(t){t._pullAlgorithm=void 0,t._cancelAlgorithm=void 0,t._strategySizeAlgorithm=void 0}function ReadableStreamDefaultControllerClose(t){if(!ReadableStreamDefaultControllerCanCloseOrEnqueue(t))return;let r=t._controlledReadableStream;t._closeRequested=!0,0===t._queue.length&&(ReadableStreamDefaultControllerClearAlgorithms(t),ReadableStreamClose(r))}function ReadableStreamDefaultControllerEnqueue(t,r){if(!ReadableStreamDefaultControllerCanCloseOrEnqueue(t))return;let a=t._controlledReadableStream;if(IsReadableStreamLocked(a)&&ReadableStreamGetNumReadRequests(a)>0)ReadableStreamFulfillReadRequest(a,r,!1);else{let a;try{a=t._strategySizeAlgorithm(r)}catch(r){throw ReadableStreamDefaultControllerError(t,r),r}try{EnqueueValueWithSize(t,r,a)}catch(r){throw ReadableStreamDefaultControllerError(t,r),r}}ReadableStreamDefaultControllerCallPullIfNeeded(t)}function ReadableStreamDefaultControllerError(t,r){let a=t._controlledReadableStream;"readable"===a._state&&(ResetQueue(t),ReadableStreamDefaultControllerClearAlgorithms(t),ReadableStreamError(a,r))}function ReadableStreamDefaultControllerGetDesiredSize(t){let r=t._controlledReadableStream._state;return"errored"===r?null:"closed"===r?0:t._strategyHWM-t._queueTotalSize}function ReadableStreamDefaultControllerCanCloseOrEnqueue(t){let r=t._controlledReadableStream._state;return!t._closeRequested&&"readable"===r}function SetUpReadableStreamDefaultController(t,r,a,o,l,i,s){r._controlledReadableStream=t,r._queue=void 0,r._queueTotalSize=void 0,ResetQueue(r),r._started=!1,r._closeRequested=!1,r._pullAgain=!1,r._pulling=!1,r._strategySizeAlgorithm=s,r._strategyHWM=i,r._pullAlgorithm=o,r._cancelAlgorithm=l,t._readableStreamController=r;let u=a();uponPromise(n(u),()=>{r._started=!0,ReadableStreamDefaultControllerCallPullIfNeeded(r)},t=>{ReadableStreamDefaultControllerError(r,t)})}function defaultControllerBrandCheckException$1(t){return TypeError(`ReadableStreamDefaultController.prototype.${t} can only be used on a ReadableStreamDefaultController`)}function convertPipeOptions(t,r){assertDictionary(t,r);let a=null==t?void 0:t.preventAbort,o=null==t?void 0:t.preventCancel,l=null==t?void 0:t.preventClose,n=null==t?void 0:t.signal;return void 0!==n&&function(t,r){if(!function(t){if("object"!=typeof t||null===t)return!1;try{return"boolean"==typeof t.aborted}catch(t){return!1}}(t))throw TypeError(`${r} is not an AbortSignal.`)}(n,`${r} has member 'signal' that`),{preventAbort:!!a,preventCancel:!!o,preventClose:!!l,signal:n}}Object.defineProperties(ReadableStreamDefaultController.prototype,{close:{enumerable:!0},enqueue:{enumerable:!0},error:{enumerable:!0},desiredSize:{enumerable:!0}}),"symbol"==typeof r.toStringTag&&Object.defineProperty(ReadableStreamDefaultController.prototype,r.toStringTag,{value:"ReadableStreamDefaultController",configurable:!0});let ReadableStream=class ReadableStream{constructor(t={},r={}){void 0===t?t=null:assertObject(t,"First parameter");let a=convertQueuingStrategy(r,"Second parameter"),o=function(t,r){assertDictionary(t,r);let a=null==t?void 0:t.autoAllocateChunkSize,o=null==t?void 0:t.cancel,l=null==t?void 0:t.pull,n=null==t?void 0:t.start,i=null==t?void 0:t.type;return{autoAllocateChunkSize:void 0===a?void 0:convertUnsignedLongLongWithEnforceRange(a,`${r} has member 'autoAllocateChunkSize' that`),cancel:void 0===o?void 0:(assertFunction(o,`${r} has member 'cancel' that`),r=>promiseCall(o,t,[r])),pull:void 0===l?void 0:(assertFunction(l,`${r} has member 'pull' that`),r=>promiseCall(l,t,[r])),start:void 0===n?void 0:(assertFunction(n,`${r} has member 'start' that`),r=>reflectCall(n,t,[r])),type:void 0===i?void 0:function(t,r){if("bytes"!=(t=`${t}`))throw TypeError(`${r} '${t}' is not a valid enumeration value for ReadableStreamType`);return t}(i,`${r} has member 'type' that`)}}(t,"First parameter");if(InitializeReadableStream(this),"bytes"===o.type){if(void 0!==a.size)throw RangeError("The strategy for a byte stream cannot have a size function");let t=ExtractHighWaterMark(a,0);!function(t,r,a){let o=Object.create(ReadableByteStreamController.prototype),startAlgorithm=()=>void 0,pullAlgorithm=()=>n(void 0),cancelAlgorithm=()=>n(void 0);void 0!==r.start&&(startAlgorithm=()=>r.start(o)),void 0!==r.pull&&(pullAlgorithm=()=>r.pull(o)),void 0!==r.cancel&&(cancelAlgorithm=t=>r.cancel(t));let l=r.autoAllocateChunkSize;if(0===l)throw TypeError("autoAllocateChunkSize must be greater than 0");SetUpReadableByteStreamController(t,o,startAlgorithm,pullAlgorithm,cancelAlgorithm,a,l)}(this,o,t)}else{let t=ExtractSizeAlgorithm(a),r=ExtractHighWaterMark(a,1);!function(t,r,a,o){let l=Object.create(ReadableStreamDefaultController.prototype),startAlgorithm=()=>void 0,pullAlgorithm=()=>n(void 0),cancelAlgorithm=()=>n(void 0);void 0!==r.start&&(startAlgorithm=()=>r.start(l)),void 0!==r.pull&&(pullAlgorithm=()=>r.pull(l)),void 0!==r.cancel&&(cancelAlgorithm=t=>r.cancel(t)),SetUpReadableStreamDefaultController(t,l,startAlgorithm,pullAlgorithm,cancelAlgorithm,a,o)}(this,o,r,t)}}get locked(){if(!IsReadableStream(this))throw streamBrandCheckException$1("locked");return IsReadableStreamLocked(this)}cancel(t){return IsReadableStream(this)?IsReadableStreamLocked(this)?i(TypeError("Cannot cancel a stream that already has a reader")):ReadableStreamCancel(this,t):i(streamBrandCheckException$1("cancel"))}getReader(t){if(!IsReadableStream(this))throw streamBrandCheckException$1("getReader");let r=function(t,r){assertDictionary(t,r);let a=null==t?void 0:t.mode;return{mode:void 0===a?void 0:function(t,r){if("byob"!=(t=`${t}`))throw TypeError(`${r} '${t}' is not a valid enumeration value for ReadableStreamReaderMode`);return t}(a,`${r} has member 'mode' that`)}}(t,"First parameter");return void 0===r.mode?AcquireReadableStreamDefaultReader(this):new ReadableStreamBYOBReader(this)}pipeThrough(t,r={}){if(!IsReadableStream(this))throw streamBrandCheckException$1("pipeThrough");assertRequiredArgument(t,1,"pipeThrough");let a=function(t,r){assertDictionary(t,r);let a=null==t?void 0:t.readable;assertRequiredField(a,"readable","ReadableWritablePair"),assertReadableStream(a,`${r} has member 'readable' that`);let o=null==t?void 0:t.writable;return assertRequiredField(o,"writable","ReadableWritablePair"),assertWritableStream(o,`${r} has member 'writable' that`),{readable:a,writable:o}}(t,"First parameter"),o=convertPipeOptions(r,"Second parameter");if(IsReadableStreamLocked(this))throw TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked ReadableStream");if(IsWritableStreamLocked(a.writable))throw TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked WritableStream");let l=ReadableStreamPipeTo(this,a.writable,o.preventClose,o.preventAbort,o.preventCancel,o.signal);return setPromiseIsHandledToTrue(l),a.readable}pipeTo(t,r={}){let a;if(!IsReadableStream(this))return i(streamBrandCheckException$1("pipeTo"));if(void 0===t)return i("Parameter 1 is required in 'pipeTo'.");if(!IsWritableStream(t))return i(TypeError("ReadableStream.prototype.pipeTo's first argument must be a WritableStream"));try{a=convertPipeOptions(r,"Second parameter")}catch(t){return i(t)}return IsReadableStreamLocked(this)?i(TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream")):IsWritableStreamLocked(t)?i(TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream")):ReadableStreamPipeTo(this,t,a.preventClose,a.preventAbort,a.preventCancel,a.signal)}tee(){if(!IsReadableStream(this))throw streamBrandCheckException$1("tee");let t=IsReadableByteStreamController(this._readableStreamController)?function(t){let r,a,o,l,i,u=AcquireReadableStreamDefaultReader(t),d=!1,c=!1,m=!1,b=!1,h=!1,p=newPromise(t=>{i=t});function forwardReaderError(t){uponRejection(t._closedPromise,r=>{t===u&&(ReadableByteStreamControllerError(o._readableStreamController,r),ReadableByteStreamControllerError(l._readableStreamController,r),b&&h||i(void 0))})}function pullWithDefaultReader(){IsReadableStreamBYOBReader(u)&&(ReadableStreamReaderGenericRelease(u),forwardReaderError(u=AcquireReadableStreamDefaultReader(t))),ReadableStreamDefaultReaderRead(u,{_chunkSteps:r=>{s(()=>{c=!1,m=!1;let a=r;if(!b&&!h)try{a=CloneAsUint8Array(r)}catch(r){ReadableByteStreamControllerError(o._readableStreamController,r),ReadableByteStreamControllerError(l._readableStreamController,r),i(ReadableStreamCancel(t,r));return}b||ReadableByteStreamControllerEnqueue(o._readableStreamController,r),h||ReadableByteStreamControllerEnqueue(l._readableStreamController,a),d=!1,c?pull1Algorithm():m&&pull2Algorithm()})},_closeSteps:()=>{d=!1,b||ReadableByteStreamControllerClose(o._readableStreamController),h||ReadableByteStreamControllerClose(l._readableStreamController),o._readableStreamController._pendingPullIntos.length>0&&ReadableByteStreamControllerRespond(o._readableStreamController,0),l._readableStreamController._pendingPullIntos.length>0&&ReadableByteStreamControllerRespond(l._readableStreamController,0),b&&h||i(void 0)},_errorSteps:()=>{d=!1}})}function pullWithBYOBReader(r,a){IsReadableStreamDefaultReader(u)&&(ReadableStreamReaderGenericRelease(u),forwardReaderError(u=new ReadableStreamBYOBReader(t)));let n=a?l:o,p=a?o:l;ReadableStreamBYOBReaderRead(u,r,{_chunkSteps:r=>{s(()=>{c=!1,m=!1;let o=a?h:b,l=a?b:h;if(l)o||ReadableByteStreamControllerRespondWithNewView(n._readableStreamController,r);else{let a;try{a=CloneAsUint8Array(r)}catch(r){ReadableByteStreamControllerError(n._readableStreamController,r),ReadableByteStreamControllerError(p._readableStreamController,r),i(ReadableStreamCancel(t,r));return}o||ReadableByteStreamControllerRespondWithNewView(n._readableStreamController,r),ReadableByteStreamControllerEnqueue(p._readableStreamController,a)}d=!1,c?pull1Algorithm():m&&pull2Algorithm()})},_closeSteps:t=>{d=!1;let r=a?h:b,o=a?b:h;r||ReadableByteStreamControllerClose(n._readableStreamController),o||ReadableByteStreamControllerClose(p._readableStreamController),void 0!==t&&(r||ReadableByteStreamControllerRespondWithNewView(n._readableStreamController,t),!o&&p._readableStreamController._pendingPullIntos.length>0&&ReadableByteStreamControllerRespond(p._readableStreamController,0)),r&&o||i(void 0)},_errorSteps:()=>{d=!1}})}function pull1Algorithm(){if(d)return c=!0,n(void 0);d=!0;let t=ReadableByteStreamControllerGetBYOBRequest(o._readableStreamController);return null===t?pullWithDefaultReader():pullWithBYOBReader(t._view,!1),n(void 0)}function pull2Algorithm(){if(d)return m=!0,n(void 0);d=!0;let t=ReadableByteStreamControllerGetBYOBRequest(l._readableStreamController);return null===t?pullWithDefaultReader():pullWithBYOBReader(t._view,!0),n(void 0)}function startAlgorithm(){}return o=CreateReadableByteStream(startAlgorithm,pull1Algorithm,function(o){if(b=!0,r=o,h){let o=CreateArrayFromList([r,a]),l=ReadableStreamCancel(t,o);i(l)}return p}),l=CreateReadableByteStream(startAlgorithm,pull2Algorithm,function(o){if(h=!0,a=o,b){let o=CreateArrayFromList([r,a]),l=ReadableStreamCancel(t,o);i(l)}return p}),forwardReaderError(u),[o,l]}(this):function(t,r){let a,o,l,i,u;let d=AcquireReadableStreamDefaultReader(t),c=!1,m=!1,b=!1,h=!1,p=newPromise(t=>{u=t});function pullAlgorithm(){return c?m=!0:(c=!0,ReadableStreamDefaultReaderRead(d,{_chunkSteps:t=>{s(()=>{m=!1,b||ReadableStreamDefaultControllerEnqueue(l._readableStreamController,t),h||ReadableStreamDefaultControllerEnqueue(i._readableStreamController,t),c=!1,m&&pullAlgorithm()})},_closeSteps:()=>{c=!1,b||ReadableStreamDefaultControllerClose(l._readableStreamController),h||ReadableStreamDefaultControllerClose(i._readableStreamController),b&&h||u(void 0)},_errorSteps:()=>{c=!1}})),n(void 0)}function startAlgorithm(){}return l=CreateReadableStream(startAlgorithm,pullAlgorithm,function(r){if(b=!0,a=r,h){let r=CreateArrayFromList([a,o]),l=ReadableStreamCancel(t,r);u(l)}return p}),i=CreateReadableStream(startAlgorithm,pullAlgorithm,function(r){if(h=!0,o=r,b){let r=CreateArrayFromList([a,o]),l=ReadableStreamCancel(t,r);u(l)}return p}),uponRejection(d._closedPromise,t=>{ReadableStreamDefaultControllerError(l._readableStreamController,t),ReadableStreamDefaultControllerError(i._readableStreamController,t),b&&h||u(void 0)}),[l,i]}(this);return CreateArrayFromList(t)}values(t){if(!IsReadableStream(this))throw streamBrandCheckException$1("values");let r=function(t,r){assertDictionary(t,r);let a=null==t?void 0:t.preventCancel;return{preventCancel:!!a}}(t,"First parameter");return function(t,r){let a=AcquireReadableStreamDefaultReader(t),o=new ReadableStreamAsyncIteratorImpl(a,r),l=Object.create(y);return l._asyncIteratorImpl=o,l}(this,r.preventCancel)}};function CreateReadableStream(t,r,a,o=1,l=()=>1){let n=Object.create(ReadableStream.prototype);InitializeReadableStream(n);let i=Object.create(ReadableStreamDefaultController.prototype);return SetUpReadableStreamDefaultController(n,i,t,r,a,o,l),n}function CreateReadableByteStream(t,r,a){let o=Object.create(ReadableStream.prototype);InitializeReadableStream(o);let l=Object.create(ReadableByteStreamController.prototype);return SetUpReadableByteStreamController(o,l,t,r,a,0,void 0),o}function InitializeReadableStream(t){t._state="readable",t._reader=void 0,t._storedError=void 0,t._disturbed=!1}function IsReadableStream(t){return!!(typeIsObject(t)&&Object.prototype.hasOwnProperty.call(t,"_readableStreamController"))&&t instanceof ReadableStream}function IsReadableStreamLocked(t){return void 0!==t._reader}function ReadableStreamCancel(t,r){if(t._disturbed=!0,"closed"===t._state)return n(void 0);if("errored"===t._state)return i(t._storedError);ReadableStreamClose(t);let a=t._reader;void 0!==a&&IsReadableStreamBYOBReader(a)&&(a._readIntoRequests.forEach(t=>{t._closeSteps(void 0)}),a._readIntoRequests=new SimpleQueue);let o=t._readableStreamController[c](r);return PerformPromiseThen(o,noop,void 0)}function ReadableStreamClose(t){t._state="closed";let r=t._reader;void 0!==r&&(defaultReaderClosedPromiseResolve(r),IsReadableStreamDefaultReader(r)&&(r._readRequests.forEach(t=>{t._closeSteps()}),r._readRequests=new SimpleQueue))}function ReadableStreamError(t,r){t._state="errored",t._storedError=r;let a=t._reader;void 0!==a&&(defaultReaderClosedPromiseReject(a,r),IsReadableStreamDefaultReader(a)?(a._readRequests.forEach(t=>{t._errorSteps(r)}),a._readRequests=new SimpleQueue):(a._readIntoRequests.forEach(t=>{t._errorSteps(r)}),a._readIntoRequests=new SimpleQueue))}function streamBrandCheckException$1(t){return TypeError(`ReadableStream.prototype.${t} can only be used on a ReadableStream`)}function convertQueuingStrategyInit(t,r){assertDictionary(t,r);let a=null==t?void 0:t.highWaterMark;return assertRequiredField(a,"highWaterMark","QueuingStrategyInit"),{highWaterMark:convertUnrestrictedDouble(a)}}Object.defineProperties(ReadableStream.prototype,{cancel:{enumerable:!0},getReader:{enumerable:!0},pipeThrough:{enumerable:!0},pipeTo:{enumerable:!0},tee:{enumerable:!0},values:{enumerable:!0},locked:{enumerable:!0}}),"symbol"==typeof r.toStringTag&&Object.defineProperty(ReadableStream.prototype,r.toStringTag,{value:"ReadableStream",configurable:!0}),"symbol"==typeof r.asyncIterator&&Object.defineProperty(ReadableStream.prototype,r.asyncIterator,{value:ReadableStream.prototype.values,writable:!0,configurable:!0});let byteLengthSizeFunction=t=>t.byteLength;try{Object.defineProperty(byteLengthSizeFunction,"name",{value:"size",configurable:!0})}catch(t){}let ByteLengthQueuingStrategy=class ByteLengthQueuingStrategy{constructor(t){assertRequiredArgument(t,1,"ByteLengthQueuingStrategy"),t=convertQueuingStrategyInit(t,"First parameter"),this._byteLengthQueuingStrategyHighWaterMark=t.highWaterMark}get highWaterMark(){if(!IsByteLengthQueuingStrategy(this))throw byteLengthBrandCheckException("highWaterMark");return this._byteLengthQueuingStrategyHighWaterMark}get size(){if(!IsByteLengthQueuingStrategy(this))throw byteLengthBrandCheckException("size");return byteLengthSizeFunction}};function byteLengthBrandCheckException(t){return TypeError(`ByteLengthQueuingStrategy.prototype.${t} can only be used on a ByteLengthQueuingStrategy`)}function IsByteLengthQueuingStrategy(t){return!!(typeIsObject(t)&&Object.prototype.hasOwnProperty.call(t,"_byteLengthQueuingStrategyHighWaterMark"))&&t instanceof ByteLengthQueuingStrategy}Object.defineProperties(ByteLengthQueuingStrategy.prototype,{highWaterMark:{enumerable:!0},size:{enumerable:!0}}),"symbol"==typeof r.toStringTag&&Object.defineProperty(ByteLengthQueuingStrategy.prototype,r.toStringTag,{value:"ByteLengthQueuingStrategy",configurable:!0});let countSizeFunction=()=>1;try{Object.defineProperty(countSizeFunction,"name",{value:"size",configurable:!0})}catch(t){}let CountQueuingStrategy=class CountQueuingStrategy{constructor(t){assertRequiredArgument(t,1,"CountQueuingStrategy"),t=convertQueuingStrategyInit(t,"First parameter"),this._countQueuingStrategyHighWaterMark=t.highWaterMark}get highWaterMark(){if(!IsCountQueuingStrategy(this))throw countBrandCheckException("highWaterMark");return this._countQueuingStrategyHighWaterMark}get size(){if(!IsCountQueuingStrategy(this))throw countBrandCheckException("size");return countSizeFunction}};function countBrandCheckException(t){return TypeError(`CountQueuingStrategy.prototype.${t} can only be used on a CountQueuingStrategy`)}function IsCountQueuingStrategy(t){return!!(typeIsObject(t)&&Object.prototype.hasOwnProperty.call(t,"_countQueuingStrategyHighWaterMark"))&&t instanceof CountQueuingStrategy}Object.defineProperties(CountQueuingStrategy.prototype,{highWaterMark:{enumerable:!0},size:{enumerable:!0}}),"symbol"==typeof r.toStringTag&&Object.defineProperty(CountQueuingStrategy.prototype,r.toStringTag,{value:"CountQueuingStrategy",configurable:!0});let TransformStream=class TransformStream{constructor(t={},r={},a={}){let o;void 0===t&&(t=null);let l=convertQueuingStrategy(r,"Second parameter"),s=convertQueuingStrategy(a,"Third parameter"),u=function(t,r){assertDictionary(t,r);let a=null==t?void 0:t.flush,o=null==t?void 0:t.readableType,l=null==t?void 0:t.start,n=null==t?void 0:t.transform,i=null==t?void 0:t.writableType;return{flush:void 0===a?void 0:(assertFunction(a,`${r} has member 'flush' that`),r=>promiseCall(a,t,[r])),readableType:o,start:void 0===l?void 0:(assertFunction(l,`${r} has member 'start' that`),r=>reflectCall(l,t,[r])),transform:void 0===n?void 0:(assertFunction(n,`${r} has member 'transform' that`),(r,a)=>promiseCall(n,t,[r,a])),writableType:i}}(t,"First parameter");if(void 0!==u.readableType)throw RangeError("Invalid readableType specified");if(void 0!==u.writableType)throw RangeError("Invalid writableType specified");let d=ExtractHighWaterMark(s,0),c=ExtractSizeAlgorithm(s),m=ExtractHighWaterMark(l,1),b=ExtractSizeAlgorithm(l),h=newPromise(t=>{o=t});(function(t,r,a,o,l,i){function startAlgorithm(){return r}t._writable=function(t,r,a,o,l=1,n=()=>1){let i=Object.create(WritableStream.prototype);InitializeWritableStream(i);let s=Object.create(WritableStreamDefaultController.prototype);return SetUpWritableStreamDefaultController(i,s,t,r,a,o,l,n),i}(startAlgorithm,function(r){return function(t,r){let a=t._transformStreamController;if(t._backpressure){let o=t._backpressureChangePromise;return PerformPromiseThen(o,()=>{let o=t._writable,l=o._state;if("erroring"===l)throw o._storedError;return TransformStreamDefaultControllerPerformTransform(a,r)},void 0)}return TransformStreamDefaultControllerPerformTransform(a,r)}(t,r)},function(){return function(t){let r=t._readable,a=t._transformStreamController,o=a._flushAlgorithm();return TransformStreamDefaultControllerClearAlgorithms(a),PerformPromiseThen(o,()=>{if("errored"===r._state)throw r._storedError;ReadableStreamDefaultControllerClose(r._readableStreamController)},a=>{throw TransformStreamError(t,a),r._storedError})}(t)},function(r){return TransformStreamError(t,r),n(void 0)},a,o),t._readable=CreateReadableStream(startAlgorithm,function(){return TransformStreamSetBackpressure(t,!1),t._backpressureChangePromise},function(r){return TransformStreamErrorWritableAndUnblockWrite(t,r),n(void 0)},l,i),t._backpressure=void 0,t._backpressureChangePromise=void 0,t._backpressureChangePromise_resolve=void 0,TransformStreamSetBackpressure(t,!0),t._transformStreamController=void 0})(this,h,m,b,d,c),function(t,r){var a,o;let l=Object.create(TransformStreamDefaultController.prototype),transformAlgorithm=t=>{try{return TransformStreamDefaultControllerEnqueue(l,t),n(void 0)}catch(t){return i(t)}},flushAlgorithm=()=>n(void 0);void 0!==r.transform&&(transformAlgorithm=t=>r.transform(t,l)),void 0!==r.flush&&(flushAlgorithm=()=>r.flush(l)),a=transformAlgorithm,o=flushAlgorithm,l._controlledTransformStream=t,t._transformStreamController=l,l._transformAlgorithm=a,l._flushAlgorithm=o}(this,u),void 0!==u.start?o(u.start(this._transformStreamController)):o(void 0)}get readable(){if(!IsTransformStream(this))throw streamBrandCheckException("readable");return this._readable}get writable(){if(!IsTransformStream(this))throw streamBrandCheckException("writable");return this._writable}};function IsTransformStream(t){return!!(typeIsObject(t)&&Object.prototype.hasOwnProperty.call(t,"_transformStreamController"))&&t instanceof TransformStream}function TransformStreamError(t,r){ReadableStreamDefaultControllerError(t._readable._readableStreamController,r),TransformStreamErrorWritableAndUnblockWrite(t,r)}function TransformStreamErrorWritableAndUnblockWrite(t,r){TransformStreamDefaultControllerClearAlgorithms(t._transformStreamController),WritableStreamDefaultControllerErrorIfNeeded(t._writable._writableStreamController,r),t._backpressure&&TransformStreamSetBackpressure(t,!1)}function TransformStreamSetBackpressure(t,r){void 0!==t._backpressureChangePromise&&t._backpressureChangePromise_resolve(),t._backpressureChangePromise=newPromise(r=>{t._backpressureChangePromise_resolve=r}),t._backpressure=r}Object.defineProperties(TransformStream.prototype,{readable:{enumerable:!0},writable:{enumerable:!0}}),"symbol"==typeof r.toStringTag&&Object.defineProperty(TransformStream.prototype,r.toStringTag,{value:"TransformStream",configurable:!0});let TransformStreamDefaultController=class TransformStreamDefaultController{constructor(){throw TypeError("Illegal constructor")}get desiredSize(){if(!IsTransformStreamDefaultController(this))throw defaultControllerBrandCheckException("desiredSize");let t=this._controlledTransformStream._readable._readableStreamController;return ReadableStreamDefaultControllerGetDesiredSize(t)}enqueue(t){if(!IsTransformStreamDefaultController(this))throw defaultControllerBrandCheckException("enqueue");TransformStreamDefaultControllerEnqueue(this,t)}error(t){if(!IsTransformStreamDefaultController(this))throw defaultControllerBrandCheckException("error");TransformStreamError(this._controlledTransformStream,t)}terminate(){if(!IsTransformStreamDefaultController(this))throw defaultControllerBrandCheckException("terminate");(function(t){let r=t._controlledTransformStream,a=r._readable._readableStreamController;ReadableStreamDefaultControllerClose(a);let o=TypeError("TransformStream terminated");TransformStreamErrorWritableAndUnblockWrite(r,o)})(this)}};function IsTransformStreamDefaultController(t){return!!(typeIsObject(t)&&Object.prototype.hasOwnProperty.call(t,"_controlledTransformStream"))&&t instanceof TransformStreamDefaultController}function TransformStreamDefaultControllerClearAlgorithms(t){t._transformAlgorithm=void 0,t._flushAlgorithm=void 0}function TransformStreamDefaultControllerEnqueue(t,r){let a=t._controlledTransformStream,o=a._readable._readableStreamController;if(!ReadableStreamDefaultControllerCanCloseOrEnqueue(o))throw TypeError("Readable side is not in a state that permits enqueue");try{ReadableStreamDefaultControllerEnqueue(o,r)}catch(t){throw TransformStreamErrorWritableAndUnblockWrite(a,t),a._readable._storedError}let l=!ReadableStreamDefaultControllerShouldCallPull(o);l!==a._backpressure&&TransformStreamSetBackpressure(a,!0)}function TransformStreamDefaultControllerPerformTransform(t,r){let a=t._transformAlgorithm(r);return PerformPromiseThen(a,void 0,r=>{throw TransformStreamError(t._controlledTransformStream,r),r})}function defaultControllerBrandCheckException(t){return TypeError(`TransformStreamDefaultController.prototype.${t} can only be used on a TransformStreamDefaultController`)}function streamBrandCheckException(t){return TypeError(`TransformStream.prototype.${t} can only be used on a TransformStream`)}Object.defineProperties(TransformStreamDefaultController.prototype,{enqueue:{enumerable:!0},error:{enumerable:!0},terminate:{enumerable:!0},desiredSize:{enumerable:!0}}),"symbol"==typeof r.toStringTag&&Object.defineProperty(TransformStreamDefaultController.prototype,r.toStringTag,{value:"TransformStreamDefaultController",configurable:!0}),t.ByteLengthQueuingStrategy=ByteLengthQueuingStrategy,t.CountQueuingStrategy=CountQueuingStrategy,t.ReadableByteStreamController=ReadableByteStreamController,t.ReadableStream=ReadableStream,t.ReadableStreamBYOBReader=ReadableStreamBYOBReader,t.ReadableStreamBYOBRequest=ReadableStreamBYOBRequest,t.ReadableStreamDefaultController=ReadableStreamDefaultController,t.ReadableStreamDefaultReader=ReadableStreamDefaultReader,t.TransformStream=TransformStream,t.TransformStreamDefaultController=TransformStreamDefaultController,t.WritableStream=WritableStream,t.WritableStreamDefaultController=WritableStreamDefaultController,t.WritableStreamDefaultWriter=WritableStreamDefaultWriter,Object.defineProperty(t,"__esModule",{value:!0})})(r)},5515:(t,r,a)=>{if(!globalThis.ReadableStream)try{let t=a(7742),{emitWarning:r}=t;try{t.emitWarning=()=>{},Object.assign(globalThis,a(2477)),t.emitWarning=r}catch(a){throw t.emitWarning=r,a}}catch(t){Object.assign(globalThis,a(5368))}try{let{Blob:t}=a(4300);t&&!t.prototype.stream&&(t.prototype.stream=function(t){let r=0,a=this;return new ReadableStream({type:"bytes",async pull(t){let o=a.slice(r,Math.min(a.size,r+65536)),l=await o.arrayBuffer();r+=l.byteLength,t.enqueue(new Uint8Array(l)),r===a.size&&t.close()}})})}catch(t){}},986:(t,r,a)=>{"use strict";a.d(r,{Z:()=>n});var o=a(9225);let l=class extends o.Z{#e=0;#t="";constructor(t,r,a={}){if(arguments.length<2)throw TypeError(`Failed to construct 'File': 2 arguments required, but only ${arguments.length} present.`);super(t,a),null===a&&(a={});let o=void 0===a.lastModified?Date.now():Number(a.lastModified);Number.isNaN(o)||(this.#e=o),this.#t=String(r)}get name(){return this.#t}get lastModified(){return this.#e}get[Symbol.toStringTag](){return"File"}static[Symbol.hasInstance](t){return!!t&&t instanceof o.Z&&/^(File)$/.test(t[Symbol.toStringTag])}},n=l},8715:(t,r,a)=>{"use strict";a.d(r,{$B:()=>i.Z,RA:()=>fileFromSync,SX:()=>blobFromSync,e2:()=>fileFrom,t6:()=>s.Z,xB:()=>blobFrom});var o=a(7561),l=a(9411),n=a(673),i=a(986),s=a(9225);let{stat:u}=o.promises,blobFromSync=(t,r)=>fromBlob((0,o.statSync)(t),t,r),blobFrom=(t,r)=>u(t).then(a=>fromBlob(a,t,r)),fileFrom=(t,r)=>u(t).then(a=>fromFile(a,t,r)),fileFromSync=(t,r)=>fromFile((0,o.statSync)(t),t,r),fromBlob=(t,r,a="")=>new s.Z([new BlobDataItem({path:r,size:t.size,lastModified:t.mtimeMs,start:0})],{type:a}),fromFile=(t,r,a="")=>new i.Z([new BlobDataItem({path:r,size:t.size,lastModified:t.mtimeMs,start:0})],(0,l.basename)(r),{type:a,lastModified:t.mtimeMs});let BlobDataItem=class BlobDataItem{#r;#a;constructor(t){this.#r=t.path,this.#a=t.start,this.size=t.size,this.lastModified=t.lastModified}slice(t,r){return new BlobDataItem({path:this.#r,lastModified:this.lastModified,size:r-t,start:this.#a+t})}async *stream(){let{mtimeMs:t}=await u(this.#r);if(t>this.lastModified)throw new n("The requested file could not be read, typically due to permission problems that have occurred after a reference to a file was acquired.","NotReadableError");yield*(0,o.createReadStream)(this.#r,{start:this.#a,end:this.#a+this.size-1})}get[Symbol.toStringTag](){return"Blob"}}},9225:(t,r,a)=>{"use strict";async function*toIterator(t,r=!0){for(let a of t)if("stream"in a)yield*a.stream();else if(ArrayBuffer.isView(a)){if(r){let t=a.byteOffset,r=a.byteOffset+a.byteLength;for(;t!==r;){let o=Math.min(r-t,65536),l=a.buffer.slice(t,t+o);t+=l.byteLength,yield new Uint8Array(l)}}else yield a}else{let t=0;for(;t!==a.size;){let r=a.slice(t,Math.min(a.size,t+65536)),o=await r.arrayBuffer();t+=o.byteLength,yield new Uint8Array(o)}}}a.d(r,{Z:()=>l}),a(5515);let o=class Blob{#o=[];#l="";#n=0;#i="transparent";constructor(t=[],r={}){if("object"!=typeof t||null===t)throw TypeError("Failed to construct 'Blob': The provided value cannot be converted to a sequence.");if("function"!=typeof t[Symbol.iterator])throw TypeError("Failed to construct 'Blob': The object must have a callable @@iterator property.");if("object"!=typeof r&&"function"!=typeof r)throw TypeError("Failed to construct 'Blob': parameter 2 cannot convert to dictionary.");null===r&&(r={});let a=new TextEncoder;for(let r of t){let t;t=ArrayBuffer.isView(r)?new Uint8Array(r.buffer.slice(r.byteOffset,r.byteOffset+r.byteLength)):r instanceof ArrayBuffer?new Uint8Array(r.slice(0)):r instanceof Blob?r:a.encode(`${r}`),this.#n+=ArrayBuffer.isView(t)?t.byteLength:t.size,this.#o.push(t)}this.#i=`${void 0===r.endings?"transparent":r.endings}`;let o=void 0===r.type?"":String(r.type);this.#l=/^[\x20-\x7E]*$/.test(o)?o:""}get size(){return this.#n}get type(){return this.#l}async text(){let t=new TextDecoder,r="";for await(let a of toIterator(this.#o,!1))r+=t.decode(a,{stream:!0});return r+t.decode()}async arrayBuffer(){let t=new Uint8Array(this.size),r=0;for await(let a of toIterator(this.#o,!1))t.set(a,r),r+=a.length;return t.buffer}stream(){let t=toIterator(this.#o,!0);return new globalThis.ReadableStream({type:"bytes",async pull(r){let a=await t.next();a.done?r.close():r.enqueue(a.value)},async cancel(){await t.return()}})}slice(t=0,r=this.size,a=""){let{size:o}=this,l=t<0?Math.max(o+t,0):Math.min(t,o),n=r<0?Math.max(o+r,0):Math.min(r,o),i=Math.max(n-l,0),s=this.#o,u=[],d=0;for(let t of s){if(d>=i)break;let r=ArrayBuffer.isView(t)?t.byteLength:t.size;if(l&&r<=l)l-=r,n-=r;else{let a;ArrayBuffer.isView(t)?d+=(a=t.subarray(l,Math.min(r,n))).byteLength:d+=(a=t.slice(l,Math.min(r,n))).size,n-=r,u.push(a),l=0}}let c=new Blob([],{type:String(a).toLowerCase()});return c.#n=i,c.#o=u,c}get[Symbol.toStringTag](){return"Blob"}static[Symbol.hasInstance](t){return t&&"object"==typeof t&&"function"==typeof t.constructor&&("function"==typeof t.stream||"function"==typeof t.arrayBuffer)&&/^(Blob|File)$/.test(t[Symbol.toStringTag])}};Object.defineProperties(o.prototype,{size:{enumerable:!0},type:{enumerable:!0},slice:{enumerable:!0}});let l=o},8803:(t,r,a)=>{"use strict";a.d(r,{Ct:()=>c,au:()=>formDataToBlob});var o=a(9225),l=a(986),{toStringTag:n,iterator:i,hasInstance:s}=Symbol,u=Math.random,d="append,set,get,getAll,delete,keys,values,entries,forEach,constructor".split(","),f=(t,r,a)=>(t+="",/^(Blob|File)$/.test(r&&r[n])?[(a=void 0!==a?a+"":"File"==r[n]?r.name:"blob",t),r.name!==a||"blob"==r[n]?new l.Z([r],a,r):r]:[t,r+""]),e=(t,r)=>(r?t:t.replace(/\r?\n|\r/g,"\r\n")).replace(/\n/g,"%0A").replace(/\r/g,"%0D").replace(/"/g,"%22"),x=(t,r,a)=>{if(r.length<a)throw TypeError(`Failed to execute '${t}' on 'FormData': ${a} arguments required, but only ${r.length} present.`)};let c=class{#s=[];constructor(...t){if(t.length)throw TypeError("Failed to construct 'FormData': parameter 1 is not of type 'HTMLFormElement'.")}get[n](){return"FormData"}[i](){return this.entries()}static[s](t){return t&&"object"==typeof t&&"FormData"===t[n]&&!d.some(r=>"function"!=typeof t[r])}append(...t){x("append",arguments,2),this.#s.push(f(...t))}delete(t){x("delete",arguments,1),t+="",this.#s=this.#s.filter(([r])=>r!==t)}get(t){x("get",arguments,1),t+="";for(var r=this.#s,a=r.length,o=0;o<a;o++)if(r[o][0]===t)return r[o][1];return null}getAll(t,r){return x("getAll",arguments,1),r=[],t+="",this.#s.forEach(a=>a[0]===t&&r.push(a[1])),r}has(t){return x("has",arguments,1),t+="",this.#s.some(r=>r[0]===t)}forEach(t,r){for(var[a,o]of(x("forEach",arguments,1),this))t.call(r,o,a,this)}set(...t){x("set",arguments,2);var r=[],a=!0;t=f(...t),this.#s.forEach(o=>{o[0]===t[0]?a&&(a=!r.push(t)):r.push(o)}),a&&r.push(t),this.#s=r}*entries(){yield*this.#s}*keys(){for(var[t]of this)yield t}*values(){for(var[,t]of this)yield t}};function formDataToBlob(t,r=o.Z){var a=`${u()}${u()}`.replace(/\./g,"").slice(-28).padStart(32,"-"),l=[],n=`--${a}\r
Content-Disposition: form-data; name="`;return t.forEach((t,r)=>"string"==typeof t?l.push(n+e(r)+`"\r
\r
${t.replace(/\r(?!\n)|(?<!\r)\n/g,"\r\n")}\r
`):l.push(n+e(r)+`"; filename="${e(t.name,1)}"\r
Content-Type: ${t.type||"application/octet-stream"}\r
\r
`,t,"\r\n")),l.push(`--${a}--`),new r(l,{type:"multipart/form-data; boundary="+a})}},4496:(t,r,a)=>{"use strict";a.r(r),a.d(r,{AbortError:()=>AbortError,Blob:()=>E.t6,FetchError:()=>FetchError,File:()=>E.$B,FormData:()=>c.Ct,Headers:()=>Headers,Request:()=>Request,Response:()=>Response,blobFrom:()=>E.xB,blobFromSync:()=>E.SX,default:()=>fetch,fileFrom:()=>E.e2,fileFromSync:()=>E.RA,isRedirect:()=>isRedirect});var o=a(8849),l=a(2286),n=a(5628),i=a(4492),s=a(2254);let dist=function(t){if(!/^data:/i.test(t))throw TypeError('`uri` does not appear to be a Data URI (must begin with "data:")');t=t.replace(/\r?\n/g,"");let r=t.indexOf(",");if(-1===r||r<=4)throw TypeError("malformed data: URI");let a=t.substring(5,r).split(";"),o="",l=!1,n=a[0]||"text/plain",i=n;for(let t=1;t<a.length;t++)"base64"===a[t]?l=!0:a[t]&&(i+=`;${a[t]}`,0===a[t].indexOf("charset=")&&(o=a[t].substring(8)));a[0]||o.length||(i+=";charset=US-ASCII",o="US-ASCII");let s=l?"base64":"ascii",u=unescape(t.substring(r+1)),d=Buffer.from(u,s);return d.type=n,d.typeFull=i,d.charset=o,d};var u=a(7261),d=a(9225),c=a(8803);let FetchBaseError=class FetchBaseError extends Error{constructor(t,r){super(t),Error.captureStackTrace(this,this.constructor),this.type=r}get name(){return this.constructor.name}get[Symbol.toStringTag](){return this.constructor.name}};let FetchError=class FetchError extends FetchBaseError{constructor(t,r,a){super(t,r),a&&(this.code=this.errno=a.code,this.erroredSysCall=a.syscall)}};let m=Symbol.toStringTag,isURLSearchParameters=t=>"object"==typeof t&&"function"==typeof t.append&&"function"==typeof t.delete&&"function"==typeof t.get&&"function"==typeof t.getAll&&"function"==typeof t.has&&"function"==typeof t.set&&"function"==typeof t.sort&&"URLSearchParams"===t[m],isBlob=t=>t&&"object"==typeof t&&"function"==typeof t.arrayBuffer&&"string"==typeof t.type&&"function"==typeof t.stream&&"function"==typeof t.constructor&&/^(Blob|File)$/.test(t[m]),isAbortSignal=t=>"object"==typeof t&&("AbortSignal"===t[m]||"EventTarget"===t[m]),isDomainOrSubdomain=(t,r)=>{let a=new URL(r).hostname,o=new URL(t).hostname;return a===o||a.endsWith(`.${o}`)},isSameProtocol=(t,r)=>{let a=new URL(r).protocol,o=new URL(t).protocol;return a===o},b=(0,u.promisify)(i.pipeline),h=Symbol("Body internals");let Body=class Body{constructor(t,{size:r=0}={}){let a=null;null===t?t=null:isURLSearchParameters(t)?t=s.Buffer.from(t.toString()):isBlob(t)||s.Buffer.isBuffer(t)||(u.types.isAnyArrayBuffer(t)?t=s.Buffer.from(t):ArrayBuffer.isView(t)?t=s.Buffer.from(t.buffer,t.byteOffset,t.byteLength):t instanceof i||(t instanceof c.Ct?a=(t=(0,c.au)(t)).type.split("=")[1]:t=s.Buffer.from(String(t))));let o=t;s.Buffer.isBuffer(t)?o=i.Readable.from(t):isBlob(t)&&(o=i.Readable.from(t.stream())),this[h]={body:t,stream:o,boundary:a,disturbed:!1,error:null},this.size=r,t instanceof i&&t.on("error",t=>{let r=t instanceof FetchBaseError?t:new FetchError(`Invalid response body while trying to fetch ${this.url}: ${t.message}`,"system",t);this[h].error=r})}get body(){return this[h].stream}get bodyUsed(){return this[h].disturbed}async arrayBuffer(){let{buffer:t,byteOffset:r,byteLength:a}=await consumeBody(this);return t.slice(r,r+a)}async formData(){let t=this.headers.get("content-type");if(t.startsWith("application/x-www-form-urlencoded")){let t=new c.Ct,r=new URLSearchParams(await this.text());for(let[a,o]of r)t.append(a,o);return t}let{toFormData:r}=await a.e(938).then(a.bind(a,9938));return r(this.body,t)}async blob(){let t=this.headers&&this.headers.get("content-type")||this[h].body&&this[h].body.type||"",r=await this.arrayBuffer();return new d.Z([r],{type:t})}async json(){let t=await this.text();return JSON.parse(t)}async text(){let t=await consumeBody(this);return new TextDecoder().decode(t)}buffer(){return consumeBody(this)}};async function consumeBody(t){if(t[h].disturbed)throw TypeError(`body used already for: ${t.url}`);if(t[h].disturbed=!0,t[h].error)throw t[h].error;let{body:r}=t;if(null===r||!(r instanceof i))return s.Buffer.alloc(0);let a=[],o=0;try{for await(let l of r){if(t.size>0&&o+l.length>t.size){let a=new FetchError(`content size at ${t.url} over limit: ${t.size}`,"max-size");throw r.destroy(a),a}o+=l.length,a.push(l)}}catch(a){let r=a instanceof FetchBaseError?a:new FetchError(`Invalid response body while trying to fetch ${t.url}: ${a.message}`,"system",a);throw r}if(!0===r.readableEnded||!0===r._readableState.ended)try{if(a.every(t=>"string"==typeof t))return s.Buffer.from(a.join(""));return s.Buffer.concat(a,o)}catch(r){throw new FetchError(`Could not create Buffer from response body for ${t.url}: ${r.message}`,"system",r)}else throw new FetchError(`Premature close of server response while trying to fetch ${t.url}`)}Body.prototype.buffer=(0,u.deprecate)(Body.prototype.buffer,"Please use 'response.arrayBuffer()' instead of 'response.buffer()'","node-fetch#buffer"),Object.defineProperties(Body.prototype,{body:{enumerable:!0},bodyUsed:{enumerable:!0},arrayBuffer:{enumerable:!0},blob:{enumerable:!0},json:{enumerable:!0},text:{enumerable:!0},data:{get:(0,u.deprecate)(()=>{},"data doesn't exist, use json(), text(), arrayBuffer(), or body instead","https://github.com/node-fetch/node-fetch/issues/1000 (response)")}});let clone=(t,r)=>{let a,o;let{body:l}=t[h];if(t.bodyUsed)throw Error("cannot clone body after it is used");return l instanceof i&&"function"!=typeof l.getBoundary&&(a=new i.PassThrough({highWaterMark:r}),o=new i.PassThrough({highWaterMark:r}),l.pipe(a),l.pipe(o),t[h].stream=a,l=o),l},p=(0,u.deprecate)(t=>t.getBoundary(),"form-data doesn't follow the spec and requires special treatment. Use alternative package","https://github.com/node-fetch/node-fetch/issues/1167"),extractContentType=(t,r)=>null===t?null:"string"==typeof t?"text/plain;charset=UTF-8":isURLSearchParameters(t)?"application/x-www-form-urlencoded;charset=UTF-8":isBlob(t)?t.type||null:s.Buffer.isBuffer(t)||u.types.isAnyArrayBuffer(t)||ArrayBuffer.isView(t)?null:t instanceof c.Ct?`multipart/form-data; boundary=${r[h].boundary}`:t&&"function"==typeof t.getBoundary?`multipart/form-data;boundary=${p(t)}`:t instanceof i?null:"text/plain;charset=UTF-8",getTotalBytes=t=>{let{body:r}=t[h];return null===r?0:isBlob(r)?r.size:s.Buffer.isBuffer(r)?r.length:r&&"function"==typeof r.getLengthSync&&r.hasKnownLength&&r.hasKnownLength()?r.getLengthSync():null},writeToStream=async(t,{body:r})=>{null===r?t.end():await b(r,t)},y="function"==typeof o.validateHeaderName?o.validateHeaderName:t=>{if(!/^[\^`\-\w!#$%&'*+.|~]+$/.test(t)){let r=TypeError(`Header name must be a valid HTTP token [${t}]`);throw Object.defineProperty(r,"code",{value:"ERR_INVALID_HTTP_TOKEN"}),r}},S="function"==typeof o.validateHeaderValue?o.validateHeaderValue:(t,r)=>{if(/[^\t\u0020-\u007E\u0080-\u00FF]/.test(r)){let r=TypeError(`Invalid character in header content ["${t}"]`);throw Object.defineProperty(r,"code",{value:"ERR_INVALID_CHAR"}),r}};let Headers=class Headers extends URLSearchParams{constructor(t){let r=[];if(t instanceof Headers){let a=t.raw();for(let[t,o]of Object.entries(a))r.push(...o.map(r=>[t,r]))}else if(null==t);else if("object"!=typeof t||u.types.isBoxedPrimitive(t))throw TypeError("Failed to construct 'Headers': The provided value is not of type '(sequence<sequence<ByteString>> or record<ByteString, ByteString>)");else{let a=t[Symbol.iterator];if(null==a)r.push(...Object.entries(t));else{if("function"!=typeof a)throw TypeError("Header pairs must be iterable");r=[...t].map(t=>{if("object"!=typeof t||u.types.isBoxedPrimitive(t))throw TypeError("Each header pair must be an iterable object");return[...t]}).map(t=>{if(2!==t.length)throw TypeError("Each header pair must be a name/value tuple");return[...t]})}}return super(r=r.length>0?r.map(([t,r])=>(y(t),S(t,String(r)),[String(t).toLowerCase(),String(r)])):void 0),new Proxy(this,{get(t,r,a){switch(r){case"append":case"set":return(a,o)=>(y(a),S(a,String(o)),URLSearchParams.prototype[r].call(t,String(a).toLowerCase(),String(o)));case"delete":case"has":case"getAll":return a=>(y(a),URLSearchParams.prototype[r].call(t,String(a).toLowerCase()));case"keys":return()=>(t.sort(),new Set(URLSearchParams.prototype.keys.call(t)).keys());default:return Reflect.get(t,r,a)}}})}get[Symbol.toStringTag](){return this.constructor.name}toString(){return Object.prototype.toString.call(this)}get(t){let r=this.getAll(t);if(0===r.length)return null;let a=r.join(", ");return/^content-encoding$/i.test(t)&&(a=a.toLowerCase()),a}forEach(t,r){for(let a of this.keys())Reflect.apply(t,r,[this.get(a),a,this])}*values(){for(let t of this.keys())yield this.get(t)}*entries(){for(let t of this.keys())yield[t,this.get(t)]}[Symbol.iterator](){return this.entries()}raw(){return[...this.keys()].reduce((t,r)=>(t[r]=this.getAll(r),t),{})}[Symbol.for("nodejs.util.inspect.custom")](){return[...this.keys()].reduce((t,r)=>{let a=this.getAll(r);return"host"===r?t[r]=a[0]:t[r]=a.length>1?a:a[0],t},{})}};Object.defineProperties(Headers.prototype,["get","entries","forEach","values"].reduce((t,r)=>(t[r]={enumerable:!0},t),{}));let R=new Set([301,302,303,307,308]),isRedirect=t=>R.has(t),g=Symbol("Response internals");let Response=class Response extends Body{constructor(t=null,r={}){super(t,r);let a=null!=r.status?r.status:200,o=new Headers(r.headers);if(null!==t&&!o.has("Content-Type")){let r=extractContentType(t,this);r&&o.append("Content-Type",r)}this[g]={type:"default",url:r.url,status:a,statusText:r.statusText||"",headers:o,counter:r.counter,highWaterMark:r.highWaterMark}}get type(){return this[g].type}get url(){return this[g].url||""}get status(){return this[g].status}get ok(){return this[g].status>=200&&this[g].status<300}get redirected(){return this[g].counter>0}get statusText(){return this[g].statusText}get headers(){return this[g].headers}get highWaterMark(){return this[g].highWaterMark}clone(){return new Response(clone(this,this.highWaterMark),{type:this.type,url:this.url,status:this.status,statusText:this.statusText,headers:this.headers,ok:this.ok,redirected:this.redirected,size:this.size,highWaterMark:this.highWaterMark})}static redirect(t,r=302){if(!isRedirect(r))throw RangeError('Failed to execute "redirect" on "response": Invalid status code');return new Response(null,{headers:{location:new URL(t).toString()},status:r})}static error(){let t=new Response(null,{status:0,statusText:""});return t[g].type="error",t}static json(t,r={}){let a=JSON.stringify(t);if(void 0===a)throw TypeError("data is not JSON serializable");let o=new Headers(r&&r.headers);return o.has("content-type")||o.set("content-type","application/json"),new Response(a,{...r,headers:o})}get[Symbol.toStringTag](){return"Response"}};Object.defineProperties(Response.prototype,{type:{enumerable:!0},url:{enumerable:!0},status:{enumerable:!0},ok:{enumerable:!0},redirected:{enumerable:!0},statusText:{enumerable:!0},headers:{enumerable:!0},clone:{enumerable:!0}});var _=a(1041);let getSearch=t=>{if(t.search)return t.search;let r=t.href.length-1,a=t.hash||("#"===t.href[r]?"#":"");return"?"===t.href[r-a.length]?"?":""};var C=a(7503);function stripURLForUseAsAReferrer(t,r=!1){return null==t?"no-referrer":(t=new URL(t),/^(about|blob|data):$/.test(t.protocol))?"no-referrer":(t.username="",t.password="",t.hash="",r&&(t.pathname="",t.search=""),t)}let w=new Set(["","no-referrer","no-referrer-when-downgrade","same-origin","origin","strict-origin","origin-when-cross-origin","strict-origin-when-cross-origin","unsafe-url"]);function isUrlPotentiallyTrustworthy(t){return!!(/^about:(blank|srcdoc)$/.test(t)||"data:"===t.protocol||/^(blob|filesystem):$/.test(t.protocol))||function(t){if(/^(http|ws)s:$/.test(t.protocol))return!0;let r=t.host.replace(/(^\[)|(]$)/g,""),a=(0,C.isIP)(r);return!!(4===a&&/^127\./.test(r)||6===a&&/^(((0+:){7})|(::(0+:){0,6}))0*1$/.test(r))||!("localhost"===t.host||t.host.endsWith(".localhost"))&&"file:"===t.protocol}(t)}let v=Symbol("Request internals"),isRequest=t=>"object"==typeof t&&"object"==typeof t[v],B=(0,u.deprecate)(()=>{},".data is not a valid RequestInit property, use .body instead","https://github.com/node-fetch/node-fetch/issues/1000 (request)");let Request=class Request extends Body{constructor(t,r={}){let a;if(isRequest(t)?a=new URL(t.url):(a=new URL(t),t={}),""!==a.username||""!==a.password)throw TypeError(`${a} is an url with embedded credentials.`);let o=r.method||t.method||"GET";if(/^(delete|get|head|options|post|put)$/i.test(o)&&(o=o.toUpperCase()),!isRequest(r)&&"data"in r&&B(),(null!=r.body||isRequest(t)&&null!==t.body)&&("GET"===o||"HEAD"===o))throw TypeError("Request with GET/HEAD method cannot have body");let l=r.body?r.body:isRequest(t)&&null!==t.body?clone(t):null;super(l,{size:r.size||t.size||0});let n=new Headers(r.headers||t.headers||{});if(null!==l&&!n.has("Content-Type")){let t=extractContentType(l,this);t&&n.set("Content-Type",t)}let i=isRequest(t)?t.signal:null;if("signal"in r&&(i=r.signal),null!=i&&!isAbortSignal(i))throw TypeError("Expected signal to be an instanceof AbortSignal or EventTarget");let s=null==r.referrer?t.referrer:r.referrer;if(""===s)s="no-referrer";else if(s){let t=new URL(s);s=/^about:(\/\/)?client$/.test(t)?"client":t}else s=void 0;this[v]={method:o,redirect:r.redirect||t.redirect||"follow",headers:n,parsedURL:a,signal:i,referrer:s},this.follow=void 0===r.follow?void 0===t.follow?20:t.follow:r.follow,this.compress=void 0===r.compress?void 0===t.compress||t.compress:r.compress,this.counter=r.counter||t.counter||0,this.agent=r.agent||t.agent,this.highWaterMark=r.highWaterMark||t.highWaterMark||16384,this.insecureHTTPParser=r.insecureHTTPParser||t.insecureHTTPParser||!1,this.referrerPolicy=r.referrerPolicy||t.referrerPolicy||""}get method(){return this[v].method}get url(){return(0,_.format)(this[v].parsedURL)}get headers(){return this[v].headers}get redirect(){return this[v].redirect}get signal(){return this[v].signal}get referrer(){return"no-referrer"===this[v].referrer?"":"client"===this[v].referrer?"about:client":this[v].referrer?this[v].referrer.toString():void 0}get referrerPolicy(){return this[v].referrerPolicy}set referrerPolicy(t){this[v].referrerPolicy=function(t){if(!w.has(t))throw TypeError(`Invalid referrerPolicy: ${t}`);return t}(t)}clone(){return new Request(this)}get[Symbol.toStringTag](){return"Request"}};Object.defineProperties(Request.prototype,{method:{enumerable:!0},url:{enumerable:!0},headers:{enumerable:!0},redirect:{enumerable:!0},clone:{enumerable:!0},signal:{enumerable:!0},referrer:{enumerable:!0},referrerPolicy:{enumerable:!0}});let getNodeRequestOptions=t=>{let{parsedURL:r}=t[v],a=new Headers(t[v].headers);a.has("Accept")||a.set("Accept","*/*");let o=null;if(null===t.body&&/^(post|put)$/i.test(t.method)&&(o="0"),null!==t.body){let r=getTotalBytes(t);"number"!=typeof r||Number.isNaN(r)||(o=String(r))}o&&a.set("Content-Length",o),""===t.referrerPolicy&&(t.referrerPolicy="strict-origin-when-cross-origin"),t.referrer&&"no-referrer"!==t.referrer?t[v].referrer=function(t,{referrerURLCallback:r,referrerOriginCallback:a}={}){if("no-referrer"===t.referrer||""===t.referrerPolicy)return null;let o=t.referrerPolicy;if("about:client"===t.referrer)return"no-referrer";let l=t.referrer,n=stripURLForUseAsAReferrer(l),i=stripURLForUseAsAReferrer(l,!0);n.toString().length>4096&&(n=i),r&&(n=r(n)),a&&(i=a(i));let s=new URL(t.url);switch(o){case"no-referrer":return"no-referrer";case"origin":return i;case"unsafe-url":return n;case"strict-origin":if(isUrlPotentiallyTrustworthy(n)&&!isUrlPotentiallyTrustworthy(s))return"no-referrer";return i.toString();case"strict-origin-when-cross-origin":if(n.origin===s.origin)return n;if(isUrlPotentiallyTrustworthy(n)&&!isUrlPotentiallyTrustworthy(s))return"no-referrer";return i;case"same-origin":if(n.origin===s.origin)return n;return"no-referrer";case"origin-when-cross-origin":if(n.origin===s.origin)return n;return i;case"no-referrer-when-downgrade":if(isUrlPotentiallyTrustworthy(n)&&!isUrlPotentiallyTrustworthy(s))return"no-referrer";return n;default:throw TypeError(`Invalid referrerPolicy: ${o}`)}}(t):t[v].referrer="no-referrer",t[v].referrer instanceof URL&&a.set("Referer",t.referrer),a.has("User-Agent")||a.set("User-Agent","node-fetch"),t.compress&&!a.has("Accept-Encoding")&&a.set("Accept-Encoding","gzip, deflate, br");let{agent:l}=t;"function"==typeof l&&(l=l(r));let n=getSearch(r),i={path:r.pathname+n,method:t.method,headers:a[Symbol.for("nodejs.util.inspect.custom")](),insecureHTTPParser:t.insecureHTTPParser,agent:l};return{parsedURL:r,options:i}};let AbortError=class AbortError extends FetchBaseError{constructor(t,r="aborted"){super(t,r)}};var E=a(8715);let P=new Set(["data:","http:","https:"]);async function fetch(t,r){return new Promise((a,u)=>{let d=new Request(t,r),{parsedURL:c,options:m}=getNodeRequestOptions(d);if(!P.has(c.protocol))throw TypeError(`node-fetch cannot load ${t}. URL scheme "${c.protocol.replace(/:$/,"")}" is not supported.`);if("data:"===c.protocol){let t=dist(d.url),r=new Response(t,{headers:{"Content-Type":t.typeFull}});a(r);return}let b=("https:"===c.protocol?l:o).request,{signal:h}=d,p=null,abort=()=>{let t=new AbortError("The operation was aborted.");u(t),d.body&&d.body instanceof i.Readable&&d.body.destroy(t),p&&p.body&&p.body.emit("error",t)};if(h&&h.aborted){abort();return}let abortAndFinalize=()=>{abort(),finalize()},R=b(c.toString(),m);h&&h.addEventListener("abort",abortAndFinalize);let finalize=()=>{R.abort(),h&&h.removeEventListener("abort",abortAndFinalize)};R.on("error",t=>{u(new FetchError(`request to ${d.url} failed, reason: ${t.message}`,"system",t)),finalize()}),function(t,r){let a;let o=s.Buffer.from("0\r\n\r\n"),l=!1,n=!1;t.on("response",t=>{let{headers:r}=t;l="chunked"===r["transfer-encoding"]&&!r["content-length"]}),t.on("socket",i=>{let onSocketClose=()=>{if(l&&!n){let t=Error("Premature close");t.code="ERR_STREAM_PREMATURE_CLOSE",r(t)}},onData=t=>{(n=0===s.Buffer.compare(t.slice(-5),o))||!a||(n=0===s.Buffer.compare(a.slice(-3),o.slice(0,3))&&0===s.Buffer.compare(t.slice(-2),o.slice(3))),a=t};i.prependListener("close",onSocketClose),i.on("data",onData),t.on("close",()=>{i.removeListener("close",onSocketClose),i.removeListener("data",onData)})})}(R,t=>{p&&p.body&&p.body.destroy(t)}),process.version<"v14"&&R.on("socket",t=>{let r;t.prependListener("end",()=>{r=t._eventsCount}),t.prependListener("close",a=>{if(p&&r<t._eventsCount&&!a){let t=Error("Premature close");t.code="ERR_STREAM_PREMATURE_CLOSE",p.body.emit("error",t)}})}),R.on("response",t=>{R.setTimeout(0);let o=function(t=[]){return new Headers(t.reduce((t,r,a,o)=>(a%2==0&&t.push(o.slice(a,a+2)),t),[]).filter(([t,r])=>{try{return y(t),S(t,String(r)),!0}catch{return!1}}))}(t.rawHeaders);if(isRedirect(t.statusCode)){let l=o.get("Location"),n=null;try{n=null===l?null:new URL(l,d.url)}catch{if("manual"!==d.redirect){u(new FetchError(`uri requested responds with an invalid redirect URL: ${l}`,"invalid-redirect")),finalize();return}}switch(d.redirect){case"error":u(new FetchError(`uri requested responds with a redirect, redirect mode is set to error: ${d.url}`,"no-redirect")),finalize();return;case"manual":break;case"follow":{if(null===n)break;if(d.counter>=d.follow){u(new FetchError(`maximum redirect reached at: ${d.url}`,"max-redirect")),finalize();return}let l={headers:new Headers(d.headers),follow:d.follow,counter:d.counter+1,agent:d.agent,compress:d.compress,method:d.method,body:clone(d),signal:d.signal,size:d.size,referrer:d.referrer,referrerPolicy:d.referrerPolicy};if(!isDomainOrSubdomain(d.url,n)||!isSameProtocol(d.url,n))for(let t of["authorization","www-authenticate","cookie","cookie2"])l.headers.delete(t);if(303!==t.statusCode&&d.body&&r.body instanceof i.Readable){u(new FetchError("Cannot follow redirect with body being a readable stream","unsupported-redirect")),finalize();return}(303===t.statusCode||(301===t.statusCode||302===t.statusCode)&&"POST"===d.method)&&(l.method="GET",l.body=void 0,l.headers.delete("content-length"));let s=function(t){let r=(t.get("referrer-policy")||"").split(/[,\s]+/),a="";for(let t of r)t&&w.has(t)&&(a=t);return a}(o);s&&(l.referrerPolicy=s),a(fetch(new Request(n,l))),finalize();return}default:return u(TypeError(`Redirect option '${d.redirect}' is not a valid value of RequestRedirect`))}}h&&t.once("end",()=>{h.removeEventListener("abort",abortAndFinalize)});let l=(0,i.pipeline)(t,new i.PassThrough,t=>{t&&u(t)});process.version<"v12.10"&&t.on("aborted",abortAndFinalize);let s={url:d.url,status:t.statusCode,statusText:t.statusMessage,headers:o,size:d.size,counter:d.counter,highWaterMark:d.highWaterMark},c=o.get("Content-Encoding");if(!d.compress||"HEAD"===d.method||null===c||204===t.statusCode||304===t.statusCode){a(p=new Response(l,s));return}let m={flush:n.Z_SYNC_FLUSH,finishFlush:n.Z_SYNC_FLUSH};if("gzip"===c||"x-gzip"===c){l=(0,i.pipeline)(l,n.createGunzip(m),t=>{t&&u(t)}),a(p=new Response(l,s));return}if("deflate"===c||"x-deflate"===c){let r=(0,i.pipeline)(t,new i.PassThrough,t=>{t&&u(t)});r.once("data",t=>{l=(15&t[0])==8?(0,i.pipeline)(l,n.createInflate(),t=>{t&&u(t)}):(0,i.pipeline)(l,n.createInflateRaw(),t=>{t&&u(t)}),a(p=new Response(l,s))}),r.once("end",()=>{p||a(p=new Response(l,s))});return}if("br"===c){l=(0,i.pipeline)(l,n.createBrotliDecompress(),t=>{t&&u(t)}),a(p=new Response(l,s));return}a(p=new Response(l,s))}),writeToStream(R,d).catch(u)})}}};